{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2022-07-10T01:06:03.887337+00:00",
  "repo": "trustoverip/tswg-acdc-specification",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 6,
      "id": "I_kwDOGxcvRc5GV4sY",
      "title": "ACDC Semantic - Why not to use JSON Schema",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/issues/6",
      "state": "OPEN",
      "author": "mitfik",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Based on the current discussion over the recent ACDC call I wanted to raise an important topic in my opinion related to the proposed specification around the semantic part.\r\n\r\nAs we all agreed the ACDC needs to be end-verifiable, security comes first, this is why any reference needs to be done through SAID (or similar content-addressable identifier) to make sure that the cryptographic commitment would be valid. \r\n\r\nThe current specification suggests solely on JSON Schema, and I would suggest rethinking that since in my opinion this could harm ACDC development and adoption.\r\n\r\nSome of the arguments which are in favor of JSON Schema which I was able to capture are:\r\n- a vast ecosystem of tools and libraries \r\n- adoption vector since JSON Schema is used in many areas\r\n- human-readable\r\n- simple to use\r\n- ... others?\r\n\r\nBut there are some significant issues related to it:\r\n- first of all to make it clear JSON Schema is \"just an IETF draft\" - Expires: June 11, 2021 \r\n  that is not much of the issue for me just wanted to point that out, if someone would like to use that argument as well as adopted specification.\r\n- lack of support for common types\r\n   JSON Schema support just [basic data types](https://json-schema.org/understanding-json-schema/reference/type.html) which makes it hard to model complex data e.g. medical data. It does support `format` annotation but this is just annotation, which means it does not have to be implemented and the implementation can vary. We can treat that as a custom feature in most cases. This means that if we want to have a date, we can not choose from `dd/mm/yy` or `mm/dd/yyyy` even if we would enforce `format` in the validation step, the object, which is optional we would be limited to that what the given tool is implementing, without a way to pass that information all the way down with ACDC.\r\n-  `$schema` keyword \r\n    Alt ought not mandatory it is recommended, the attribute allows to define which version of the schema we are referring to. Unfortunately, it is URL. Sounds familiar? JSON-LD? \r\n    We can't allow using that keyword since we can't assure about the immutability of those objects pointing to the location. So we can skip the completely or enforce to use SAID instead but then most of the validators would fail on that and we need a custom one. Why is important to address that since people would use it since it is out of the box, here is an example from `vLEI`\r\n    ```\r\n    {\r\n        \"$id\": \"ExBYRwKdVGTWFq1M3IrewjKRhKusW9p9fdsdD0aSTWQI\",\r\n        \"$schema\": \"http://json-schema.org/draft-07/schema#\",\r\n        \"title\": \"GLEIF vLEI Credential\",\r\n       ...        \r\n    ```\r\n   In some cases that do no harm, but changing the meaning of the semantic can lead to change the meaning of the data (e.g. change from `boolean` to `string` which could validate as  `true` even if their value would be `false`). If it is allowed to do it wrong people would do so.\r\n - `$id` keyword - Almost the same problem as above, according to the spec the `$id` need to be URI - SAID is not URI per definition, so we would need to create one to stay complaint. As you can guess above vLEI won't validate against standard JSON Schema validator. According to the spec: `The value of $id is a URI-reference without a fragment that resolves against the [Retrieval URI](https://json-schema.org/understanding-json-schema/structuring.html#retrieval-uri). ` Which again leads us to \"JSON-LD\" hell if we won't be based on content-addressable identifiers. Why needs to be URI which is resolved? because `$id` embedded in subschema can use its base URI to resolve against.  \r\n- `$ref` keyword - optional but can be used as a reference to another schema. This allows us to have some sort of composability, but if we won't use content addressable identifiers we lose security. The URI-references in `$ref` resolve against the schema\u2019s [Base URI](https://json-schema.org/understanding-json-schema/structuring.html#base-uri)\r\n- JSON Schema is used in OAS\r\n  The problem is that even OAS is not using JSON schema as it is, they use [extended subset](https://swagger.io/specification/#data-types) (not even subset but extended) of JSON Schema [Specification Wright Draft 00](https://json-schema.org/)., and modified it quite to fit their needs. This means that even if you would like to leverage the JSON schema ecosystem you would exclude OAS (which probably is way bigger) and if you would like to stay compliant with OAS you need to ditch standard spec. I would even argue that OAS would be better than JSON schema but won't solve the problem either.  \r\n\r\nJSON Schema was designed with the mind of the web, this is why is heavily influenced but pattern designs for the location-based network. \r\n\r\nWith ACDC we are going towards a content-based network and this is why we should be careful to pick related specifications to be used since they break a lot of security aspects of our architecture. \r\n\r\nIn addition, ACDC is agnostic to the serialization format, we can have it in JSON, XML, etc. What if I would like to have XML serialization do I still need to use JSON schema to parse my XML ACDC? \r\n\r\nTo summarize it, ACDC should not reference JSON Schema as a main semantic description it does not have any properties which can help with what we need:\r\n- support for complex data types to be able to describe simple but as well very complex data structure,\r\n- immutable objects across whole chain, no URI or URLs, it needs to be mandatory to use content addressable identifiers\r\n- capturing meaning of data (rich layered architecture to be able to achieve that)\r\n- reusability of schema to increase interoperability of the data\r\n\r\nAs you know I am one of the co-authors of OCA (Overlays Capture Architecture) where the last 4 years we spent building an alternative to existing semantic solutions. We did quite some research in that space and tried to aggregate all important characteristics of the semantic which is needed to capture the meaning of data. A few important take away from that effort is that:\r\n- you can NOT convince everyone to name stuff the same way as you do\r\n- you have to go with layered architecture to decouple responsibility to increase interoperability of the objects.\r\n\r\nI am not saying that ACDC should force to use OCA (although that would be nice) but define the specification in a way that would focus on the characteristics of such solution and not a specific implementation. I know that this could make the implementation more complex but through the adoption, we would show which one is the best and people would gravitate towards the best anyway.  \r\n\r\nWe could apply same principle as we have with SAID or SCID where first byte would let you know not only which hashing algorithm it is but as well which type of semantic is behind that. \r\n\r\nIf you would like to learn about such characteristics I recommend to take a look on [OCA](https://the-human-colossus-foundation.github.io/oca-spec/): [https://the-human-colossus-foundation.github.io/oca-spec/](https://the-human-colossus-foundation.github.io/oca-spec/)\r\n\r\n\r\nHappy to hear your opinion about above points.\r\n\r\n\r\n \r\n",
      "createdAt": "2022-03-24T23:05:11Z",
      "updatedAt": "2022-05-07T18:18:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the comments. I will go through them in detail. tomorrow.\n\nMy initial reaction is that JSON Schema are sufficiently expressive that we can create overlays that support OCA but leverage the extensive already universally adopted tooling for JSON Schema.  We just have to define a static profile of JSON Schema to ensure security. Most users of JSON Schema use static schema so it does not pose a problem to leverage the tooling this way  One of the biggest adoption barriers is tooling and given that apparently OCA will be an open spec but the HSF implementation will be closed (non-FLOSS) then its a strong reason not to use OCA unless it is an overlay on top of open JSON Schema tooling. I strongly object to the development of standards where the primary (reference) implementation is not at least as open as the standard spec itself.  \n\nSent from my iPad\n\n> On Mar 24, 2022, at 17:05, Robert Mitwicki ***@***.***> wrote:\n> \n> \ufeff\n> Based on the current discussion over the recent ACDC call I wanted to raise an important topic in my opinion related to the proposed specification around the semantic part.\n> \n> As we all agreed the ACDC needs to be end-verifiable, security comes first, this is why any reference needs to be done through SAID (or similar content-addressable identifier) to make sure that the cryptographic commitment would be valid.\n> \n> The current specification suggests solely on JSON Schema, and I would suggest rethinking that since in my opinion this could harm ACDC development and adoption.\n> \n> Some of the arguments which are in favor of JSON Schema which I was able to capture are:\n> \n> a vast ecosystem of tools and libraries\n> adoption vector since JSON Schema is used in many areas\n> human-readable\n> simple to use\n> ... others?\n> But there are some significant issues related to it:\n> \n> first of all to make it clear JSON Schema is \"just an IETF draft\" - Expires: June 11, 2021\n> that is not much of the issue for me just wanted to point that out, if someone would like to use that argument as well as adopted specification.\n> lack of support for common types\n> JSON Schema support just basic data types which makes it hard to model complex data e.g. medical data. It does support format annotation but this is just annotation, which means it does not have to be implemented and the implementation can vary. We can treat that as a custom feature in most cases. This means that if we want to have a date, we can not choose from dd/mm/yy or mm/dd/yyyy even if we would enforce format in the validation step, the object, which is optional we would be limited to that what the given tool is implementing, without a way to pass that information all the way down with ACDC.\n> $schema keyword\n> Alt ought not mandatory it is recommended, the attribute allows to define which version of the schema we are referring to. Unfortunately, it is URL. Sounds familiar? JSON-LD?\n> We can't allow using that keyword since we can't assure about the immutability of those objects pointing to the location. So we can skip the completely or enforce to use SAID instead but then most of the validators would fail on that and we need a custom one. Why is important to address that since people would use it since it is out of the box, here is an example from vLEI\n> {\n>     \"$id\": \"ExBYRwKdVGTWFq1M3IrewjKRhKusW9p9fdsdD0aSTWQI\",\n>     \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n>     \"title\": \"GLEIF vLEI Credential\",\n>    ...        \n> In some cases that do no harm, but changing the meaning of the semantic can lead to change the meaning of the data (e.g. change from boolean to string which could validate as true even if their value would be false). If it is allowed to do it wrong people would do so.\n> $id keyword - Almost the same problem as above, according to the spec the $id need to be URI - SAID is not URI per definition, so we would need to create one to stay complaint. As you can guess above vLEI won't validate against standard JSON Schema validator. According to the spec: The value of $id is a URI-reference without a fragment that resolves against the [Retrieval URI](https://json-schema.org/understanding-json-schema/structuring.html#retrieval-uri). Which again leads us to \"JSON-LD\" hell if we won't be based on content-addressable identifiers. Why needs to be URI which is resolved? because $id embedded in subschema can use its base URI to resolve against.\n> $ref keyword - optional but can be used as a reference to another schema. This allows us to have some sort of composability, but if we won't use content addressable identifiers we lose security. The URI-references in $ref resolve against the schema\u2019s Base URI\n> JSON Schema is used in OAS\n> The problem is that even OAS is not using JSON schema as it is, they use extended subset (not even subset but extended) of JSON Schema Specification Wright Draft 00., and modified it quite to fit their needs. This means that even if you would like to leverage the JSON schema ecosystem you would exclude OAS (which probably is way bigger) and if you would like to stay compliant with OAS you need to ditch standard spec. I would even argue that OAS would be better than JSON schema but won't solve the problem either.\n> JSON Schema was designed with the mind of the web, this is why is heavily influenced but pattern designs for the location-based network.\n> \n> With ACDC we are going towards a content-based network and this is why we should be careful to pick related specifications to be used since they break a lot of security aspects of our architecture.\n> \n> In addition, ACDC is agnostic to the serialization format, we can have it in JSON, XML, etc. What if I would like to have XML serialization do I still need to use JSON schema to parse my XML ACDC?\n> \n> To summarize it, ACDC should not reference JSON Schema as a main semantic description it does not have any properties which can help with what we need:\n> \n> support for complex data types to be able to describe simple but as well very complex data structure,\n> immutable objects across whole chain, no URI or URLs, it needs to be mandatory to use content addressable identifiers\n> capturing meaning of data (rich layered architecture to be able to achieve that)\n> reusability of schema to increase interoperability of the data\n> As you know I am one of the co-authors of OCA (Overlays Capture Architecture) where the last 4 years we spent building an alternative to existing semantic solutions. We did quite some research in that space and tried to aggregate all important characteristics of the semantic which is needed to capture the meaning of data. A few important take away from that effort is that:\n> \n> you can NOT convince everyone to name stuff the same way as you do\n> you have to go with layered architecture to decouple responsibility to increase interoperability of the objects.\n> I am not saying that ACDC should force to use OCA (although that would be nice) but define the specification in a way that would focus on the characteristics of such solution and not a specific implementation. I know that this could make the implementation more complex but through the adoption, we would show which one is the best and people would gravitate towards the best anyway.\n> \n> We could apply same principle as we have with SAID or SCID where first byte would let you know not only which hashing algorithm it is but as well which type of semantic is behind that.\n> \n> If you would like to learn about such characteristics I recommend to take a look on OCA: https://the-human-colossus-foundation.github.io/oca-spec/\n> \n> Happy to hear your opinion about above points.\n> \n> \u2014\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n> You are receiving this because you are subscribed to this thread.\n",
          "createdAt": "2022-03-25T03:15:50Z",
          "updatedAt": "2022-03-25T03:15:50Z"
        },
        {
          "author": "pknowl",
          "authorAssociation": "NONE",
          "body": "The key benefit of OCA is that different actors from different institutions, departments, etc., can control specific task-oriented objects within the same OCA bundle. In other words, different actors may have dynamic control over assigned overlays rather than the entire semantic structure. Object interoperability is essential in a Dynamic Data Economy where multiple actors from various institutions participate in complex use cases, supply chains, and data flows, supported by multi-stakeholder data governance administrations and frameworks.",
          "createdAt": "2022-03-25T06:48:33Z",
          "updatedAt": "2022-03-25T06:48:33Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "@pknowl   ACDC is an over-the-wire protocol for exchanging authentic data. Once that data has been exchanged, any number of down stream semantic overlays may be imposed upon the over the wire data. So semantic overlays are good for the downstream purposes.  There is no incompatability here.  A one-to-one overlay enables over-the-wire compactness and security and semantic interoperability post processing.  The key is to use an OCA overlay over JSON Schema that is used over the wire and not to replace JSON Schema for over-the-wire.  JSON schema is the over the wire \u201ccapture base\u201d and then one defines a one-to-one OCA overlay that becomes the OCA capture base.   This is how other protocols solve the problem especially in resource constrained environments. The over-the-wire syntax is constrained.   The problem is trying to force downstream semantics upstream onto the over-the-wire constrained syntax.  We want the universal tooling already available for JSON Schema. And JSON Schema are sufficiently rich to provide the over-the-wire syntactical field type structure. A given ACDC JSON Schema can be then mapped one-to-one to a given OCA overlay. This provides clean separation of concerns.",
          "createdAt": "2022-03-25T13:32:26Z",
          "updatedAt": "2022-03-25T13:45:46Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "@pknowl JSON Schema supports regular expressions https://json-schema.org/understanding-json-schema/reference/regular_expressions.html  This means practically speaking any arbitrarily complex field type may be expressed as JSON Schema. Therefore there is no reason an OCA capture base equivalent for any OCA capture base can not be expressed as a JSON Schema. Therefore one can build one-to-one mapping overlays between JSON Schema and OCA.  The advantage of using JSON Schema is that the tooling is already supported in practically every language on every OS and every environment. The adoption battle for JSON Schema has already been fought and JSON Schema won.   ;)  Lets not fight that battle again by trying to replace JSON Schema with something that should be an overlay.",
          "createdAt": "2022-03-25T13:51:52Z",
          "updatedAt": "2022-03-25T13:51:52Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "@mitfik \r\nWith regards JSON Schema Metadata fields.\r\nNote: schema metadata fields are not schema fields. The security implications of nonlocal URIs in metadata are significantly difference than having dynamically generated schema due to nonlocal URI references in the schema itself. There are still some security implications but they are not equivalent and it is in invalid equivocation to make the comparison to JSON-LD @context which directly dynamically generates the schema and JSON schema metadata fields.\r\n\r\nThe $id field in ACDC JSON Schema is set to the SAID of that schema. It is not a URI reference. This has been true for some time.\r\n\r\nThe version field in JSON Schema is not normative it is informative. It indicates that a given version is expected but\r\n is not used to dynamically switch verson. At least not in the tooling we use. If that were so then it would be a problem. But AFAIK the URI in the version field is treated as a string and is not dereferenced. Nothing is looked up. So it is not dynamic. Its just a fixed version string expressed as a URI.  The version of the tooling called by the validator is normative.\r\n\r\nLet me elaborate: JSON Schema metadata are not schema and should not pose a that same security risk  that JSON-LD @context does. @context is not schema metadata it is used to dynamically derive the actual schema itself.. If there is any possibility of json schema metadata posing a security risk, we will constrain how it is used it in the ACDC profile. Non relative URLs in metadata do not contribute to schema. We already forbid non relative URIs in schema except for namespaced references that include the SAID. So they are locked down.\r\n\r\nIts also a stretch to state that  leaky semantics of metadata results in leaks in the actual semantics of the static schema. The key security issue for semantic drift of static schema is not the metadata but  the fidelity or  \u201ccorrectness\u201d of the tooling wrt to a given version. But like any tooling there is always the problem with ensuring that the tooling is a correct implementation. I suspect this applies to OCA implementations as well.  Merely locking down versioning expressed in schema metadata does not solve this tooling correctness problem so its a red herring to point to non-relative URLs in metadata and infer semantic drift in the actual schema. The semantic drift in the tooling may occur independently of the metadata.\r\n\r\nTo restate, this is unlike schema.org @context which is not metadata at all but is used to derive the schema itself. Its insecurity properties are therefore fundamental. Its not leaky semantics of schematic metadata that is the problem with JSON-LD, its leaky schematic syntax and leaky schematic semantics that is problematic with json-ld.\r\n\r\nSimilarly, overly expressive schema start to suffer from the inability of \u201ccorrectness\u201d verification in tooling that supports it. This is the fundamental problem with overly expressive smart contract languages. It becomes pathologically difficult to guarantee functionally correct code even with formal verification methods, DO-178C, etc. Too much expressiveness makes formal verification more difficult not less. So we will want to have a much more limited profile for JSON schema for ACDCs to better ensure we can assert \u201ccorrectness\u201d of an implementation. The one complexity we allow is composed schema which allow compactness and selective disclosure versions. Each alternate version is still simple. The composition operator oneof adds complexity in a very specific way that we can manage. \r\n",
          "createdAt": "2022-03-25T19:45:23Z",
          "updatedAt": "2022-03-25T19:45:23Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "Let me suggest both a Forest and Trees analogy and a Goldilocks analogy.  From an abstract data modeling perspective, an ACDC is best modeled as graph fragment of a directed edge labeled property graph LPG. The edges allow chaining and treeing of ACDCS into graph based semantic structures.   The properties in the ACDC attribute section provide the node properties of the fragment. The edges and edge properties of the ACDC edge section provide the edges of the graph fragment.  Complexity of data expression in an LPG should be at the graph level not the node level. You want simple nodes and simple edges composed into LPGs. So where does Goldilocks fit in. If you have nodes and edges that are TOO simple, like JSON-LD/RDF graphs then the ability to reason and model at the graph level is too hard. Even simple concepts become cumbersome because nodes are singular properties and edges are not differentiated by properties.. So Goldilocks, JSON-LD/REFD chair is too small, or TOO simple.  The other end of the spectrum is to abuse LPGs by making the nodes complex nested documents with arbitrarily complex nested field maps for the properties of the node. Indeed in this case each node is its own subgraph but this subgraph is not part of the semantics of the LPG graph to which the ACDC graph fragment belongs. The chair is too big, TOO complex.  The just right fitting chair are simple nodes with enough properties to represent a rich semantic node and enough properties on the edges to represent rich connections between rich nodes but not so complex that reasoning about them as fragments of a LPG is problematic.  \r\n\r\nWe are not leveraging the LPG model if we are making individual ACDCs complex documents in their own right. They need ot be fragments of a graph. And the graph semantics are what we care about.  So JSON Schema is more than adequate for JUST RIGHT nodes and Edges.  \r\n\r\nSo the right place in my opionion for a complex semantic overlay is not at the node level but at the graph level. A semantic overlay that provides semantics on LPGs becomes really useful.  Anything lower level than that is using a mismatch in the abstract data model.\r\n\r\nNow for the Forest and Trees analogy. An LPG graph model is the forest. An individual ACDC is a tree. Each tree has its own sourcing its own root of trust and it's easy to verify and secure and provenance. The forest is where complexity is expressed not in each tree.  If we have complex trees then we go from a forest of trees to an aspen grove where the roots of trust are all mixed together. This is difficult to securely verify. This is the node as complex document model, \r\n\r\nAnother analogy. The soup vs Ala Cart model for presentations of credentials. The soup model of credentials means that Properties from multiple sources and multiple roots of trust are mixed together in a soup and served up as a soup or stew of properties.  In contrast the ala cart model means that properties from multiple credentials are chained together in a graph of individual courses that can be individually secured and provenanced and served up as discrete courses in a meal not mixed together in a soup/stew that is a single course meal.\r\n\r\nSo in the ala cart model, semantic overlays are expressed over graphs not over documents. If an ACDC node is so complex that I need extremely complex schema overlays to understand it then I am truly missing the forest for the trees. And sitting in an uncomfortable chair slurping stew instead of sitting in a comfortable chair enjoying a multi-course meal.",
          "createdAt": "2022-03-25T20:05:16Z",
          "updatedAt": "2022-03-25T21:46:54Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "The GLEIF vLEI set of ACDCs follow this graph model of ala cart chained provenanced credentials, instead of a soup model or a complex node as document model.\r\n\r\nGLEIF -> QVI -> LEI -> ECR  -> verifier\r\n\r\n  Each credentail in that chain is simple. The Graph of that chain is rich in meaning and can be recomposed in numerous ways without creating new credentials that each require a new complex schema for each variant.  The important semantics are expressed at the level of a graph of  ACDCs not at the level of a single ACDC. \r\n\r\nA graph based semantic overlay is in abstracted graph composition elements which are decomposable into already verified, cached, provenanced fragments. So the overlay is expressed at a higher level of abstraction. The details are hidden below the graph abstraction layer. Decisions are made at this higher level of abstraction thus reducing apparent complexity to the decision maker and simplifying semantic overlay constraints on the lower layers.\r\n\r\n((GLEIF -> QVI ->  LEI)  + (GLEIF -> QVI -> LEI -> OOR)) -> verifier\r\n\r\n((GLEIF -> QVI -> LEI)  + (GLEIF -> QVI ->  LEI -> ECR)) -> verifier\r\n\r\nComposition of graph fragments provides reusability at scale. \r\nComposition of already verified graph fragments provides verifiability at scale\r\n\r\nWe can leverage the burgeoning off-the-shelf market support for LPG Decision Making and semantic composition. This includes LPG databases with Graph Query languages that naturally express semantic overlays at the graph level. Not to mention support for machine learning using weighted directed edge LPG. \r\n\r\n We can do complex graph composition to generate overlays using graph languages that already exist and have broad commercial support. We don't have to reinvent them. We just need an over-the-wire protocol that secures them. That is where they lack.\r\n\r\n\r\nACDCs provide securely attributed fragments of distributed LPGs.\r\n\r\nAll we need is to map those securely attributed (authentic) fragments to graph databases and we can leverage the full suite of semantic overlay goodness already available in the marketplace.\r\n",
          "createdAt": "2022-03-25T21:07:07Z",
          "updatedAt": "2022-03-25T21:31:12Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "I suggest if the ACDC working group is serious about semantic overlays it should figure out why the emerging GQL standard is inadequate as a semantic overlay to ACDCs using JSON Schema or any of the dozen other already available graph languages as overlays to ACDCs using JSON Schema. Until then let's stay focused on securing LPG fragments (AKA ACDCs) which will provide a zero trust architecture to feed into These Graph language overlays.    https://en.wikipedia.org/wiki/Graph_Query_Language. And if someone wants to feed them into an OCA overlay so be it. But not at the cost of precluding or delaying or replacing the already broad support for both JSON Schema tooling and LPG tooling. Tooling is the most expensive barrier to adoption. KERI is already a big lift by itself. If it were not for the fact that there is no portable (not ledger locked), securely attributable, decentralized identifier protocol alternative to KERI it would be hard to justify KERI.\r\n",
          "createdAt": "2022-03-25T21:34:46Z",
          "updatedAt": "2022-03-25T22:15:20Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "@mitfik \r\n\r\n> $ref keyword - optional but can be used as a reference to another schema. This allows us to have some sort of composability, but if we won't use content addressable identifiers we lose security. The URI-references in $ref resolve against the schema\u2019s [Base URI](https://json-schema.org/understanding-json-schema/structuring.html#base-uri)\r\n\r\nNon-relative URI references are forbidden in ACDC schema. One may use namespaced SAIDs such as a DIDURL that includes a SAID. But these are verifiable against the enclosed SAID so are not dynamic resources but are distributed static references.\r\n\r\n> JSON Schema support just [basic data types](https://json-schema.org/understanding-json-schema/reference/type.html) which makes it hard to model complex data e.g. medical data.\r\n\r\nSee above, JSON Schema support regular expressions which support any practically useful complex data type.\r\n\r\n\r\n> $schema keyword\r\n> Alt ought not mandatory it is recommended, the attribute allows to define which version of the schema we are referring to. Unfortunately, it is URL.\r\n> \r\n\r\nSee above URI references in schema metadata are not equivalent to @context JSON-LD URI references to dynamic schema. As mentioned above $schema is not normative and is not dereferenced in tooling (at least the tooling we are familiar with) but is used as a static string.\r\n\r\n> JSON Schema is used in OAS\r\n> The problem is that even OAS is not using JSON schema as it is, they use [extended subset](https://swagger.io/specification/#data-types) (not even subset but extended) of JSON Schema [Specification Wright Draft 00](https://json-schema.org/)., and modified it quite to fit their needs.\r\n\r\nThe most important thing we are leveraging from the JSON Schema ecosystem is its tooling. Tooling provides the syntax of schema expression. We do not need to leverage schema libraries. So when we say we use JSON Schema 2020-12 we mean the syntactical elements that the tooling supports. These syntactical elements enable us to express static JSON schema. Those static schema are universally parseable and validatable by any/all implementations of that tooling version. So we get instant universal adaptability via the tooling. This is leverage that counts the most. \r\n\r\nIndeed leveraging schema libraries may be entirely problematic because schema libraries often are contextualized. Each ACDC ecosystem will most likely need its own ecosystem contextualization that requires its own library of schema. These schema must be static and statically referenced with SAIDs to ensure they are secure. As I have explained in other venues, the idea of universal semantics that span contexts is entirely problematic due to polysemy and uncertainty limitations on semantic chaining inference distance. We want narrow contexts with narrowly defined schema libraries.\r\n\r\n> In addition, ACDC is agnostic to the serialization format, we can have it in JSON, XML, etc. What if I would like to have XML serialization do I still need to use JSON schema to parse my XML ACDC?\r\n\r\nACDCs only support the following four serialization JSON, CBOR, MessagePack, CESR. And for CBOR only the subset that is expressible in JSON is supportable.  ACDC does not support XML and likely never will because of XMLs dynamic type dictionary. Once you remove the dynamic type  features of XML, then there is little reason to use it over JSON. The JSON XML adoption battle has already been fought and JSON won. So other than legacy vestigial support , XML is a dead-end technology as an adoption vector.  \r\n\r\nThus JSON Schema is sufficient to support schema for all the four formats because all the four formats are mappable to dictionaries i.e. field maps (label, value) pairs or nested field maps (or arrays of such). All of which are supportable by JSON schema.  (see above the problems of correctness of TOO rich schema.\r\n\r\n\r\nBecause schema do not include any cryptographic primitives, schema do not benefit from the compactness and composability properties of CESR. Which is why KERI and ACDCs use CESR for primitives. Verbosity of schema overlay mapping is not a problem so there is no benefit to embed support for multiple schema types. We just pick one and standardize on it. JSON Schema tooling adoption and support makes it the winner.  We only need to use a subset that fits the ACDC profile requirements. So any extra fluff in JSON Schema we can safely ignore. But the most important thing is we don't have to write new tooling or support new tooling or support tooling for multiple schema formats in ACDC. If someone wants to support OCA then they just provide tooling that maps JSON Schema to OCA. Not require everyone to support multiple schema types that include OCA.  \r\n\r\nI get the fact that you want an adoption vector for OCA. But it doesn't solve an essential problem for ACDCs that JSON schema does not already solve.\r\n\r\n",
          "createdAt": "2022-03-25T23:31:37Z",
          "updatedAt": "2022-03-25T23:42:24Z"
        },
        {
          "author": "pknowl",
          "authorAssociation": "NONE",
          "body": "Thanks for your answers, @SmithSamuelM, but as OCA works from the first principles of computing, we won't compromise on either the concept or the implementation unless it is fundamentally evident that a pre-existing solution performs all of our semantic requirements with absolute integrity. At Human Colossus, we are in the throws of getting OCA version 1.0 out the door, so it is a distraction for us to spend too much energy on the _\"JSON Schema versus OCA\"_ argument until we get through the release. As we start to delve into complex use cases, I'm sure community members will begin to understand why we have constructed the architecture as we have. I appreciate the need to get things out the door from the KERI/ACDC side. We have the same pressures for OCA. We treat objectual integrity as our Layer 1 at HCF. In other words, semantics comes before authentication in our stack. Over the past four years, OCA has become a foundational cornerstone at HCF to demonstrate structural and contextual harmonisation and integrity. Our main priority is to get v1.0 out the door so that people can start to have a play. At that stage, we'll be happy to revisit the _\"JSON Schema versus OCA\"_ argument with anyone who wants to roll their sleeves up. OCA has to integrate with any existing data model or data representation format as a natural course. In that regard, it'll be able to on-ramp JSON Schema in the semantic harmonisation process. As you can appreciate, deep-stack semantics experts are (and have always been) our sounding board for OCA, and ToIP is not the right community in that regard. We've already picked at the seams in the FAIR data communities and look forward to bringing OCA back to ToIP already vetted and ready for complex use case implementations. Good luck with all of the KERI/ACDC stuff. Leave OCA to the HCF community. We'll touch base when the time is right.",
          "createdAt": "2022-03-26T07:06:43Z",
          "updatedAt": "2022-03-26T07:06:43Z"
        },
        {
          "author": "mitfik",
          "authorAssociation": "NONE",
          "body": "> Most users of JSON Schema use static schema so it does not pose a problem to leverage the tooling this way One of the biggest adoption barriers is tooling and given that apparently OCA will be an open spec but the HSF implementation will be closed (non-FLOSS) then its a strong reason not to use OCA unless it is an overlay on top of open JSON Schema tooling. I strongly object to the development of standards where the primary (reference) implementation is not at least as open as the standard spec itself.\r\n\r\nI think we can exclude that argument since OCA spec same as it's main reference implementation is developed under EUPL-1.2 which [definitely](https://joinup.ec.europa.eu/collection/eupl/how-use-eupl#section-2) is FLOSS license\r\n\r\n",
          "createdAt": "2022-03-31T09:39:35Z",
          "updatedAt": "2022-03-31T09:39:35Z"
        },
        {
          "author": "mitfik",
          "authorAssociation": "NONE",
          "body": "> @pknowl ACDC is an over-the-wire protocol for exchanging authentic data. Once that data has been exchanged, any number of down stream semantic overlays may be imposed upon the over the wire data. So semantic overlays are good for the downstream purposes. There is no incompatability here. A one-to-one overlay enables over-the-wire compactness and security and semantic interoperability post processing. The key is to use an OCA overlay over JSON Schema that is used over the wire and not to replace JSON Schema for over-the-wire. JSON schema is the over the wire \u201ccapture base\u201d and then one defines a one-to-one OCA overlay that becomes the OCA capture base. \r\n\r\nI think what we can agree on here is that we have few problems which needs to be solved separately: \r\n- data capture - capturing the meaning of the data (e.g. is it about a person or about a car)\r\n- data processing - understanding how to process the data (e.g. what date format was used, or character encoding)\r\n- data presentation - being able to present the data (e.g. in given language, layout)\r\n\r\nNow if we would try to combine all those information into one static schema we would loose quite a lot of flexibility for overall ecosystem. Above problems can be address in many ways, but we are entering into decentralized (dynamic) data economy where the intention is to let data flow. What that means is that interoperability is one of the key characteristic in this ecosystem. \r\n\r\nTo increase the interoperability of semantic parts we need to create system where we would encourage people to reuse schema as much as possible, give them a chance to adopt the schema to their needs without need to build complex data transformation pipelines or integration between wallets or system just because for example someone named attribute differently.\r\n\r\nIn my opinion one of the way to achieve that would be to define the system where 3 above challenges are decouple and address desperately on different layers.\r\n\r\nLet's look on the example:\r\nEU commission with other partners defines `capture base` to define `meaning` of the data which capture the context of driving license. They publish the `capture base` as immutable object (SAID + Signature of the Governance Framework Authority (GFA)). Then EU states or partners can reuse and apply rules on the data processing layer according to their local needs. Let say Switzerland would define that expiration date is captured in a format `dd/mm/yyyy` where US would capture same information in a format `mm/dd/yyyy`. Next local jurisdictions in Switzerland and USA states would prepare presentation layers on which they would define how it should look like (e.g. German, French, English) and how it should be presented (Logo, colors, etc.) \r\n\r\nNow let's say that someone from Switzerland visit USA - Arizona, police officer stops him for control and ask for driving license credential. He scan it validate and few things can happen:\r\n- because of the `capture base` is the same - issued under same GFA he knows that what he sees it is driving license which is valid\r\n- because of the `data processing` layers he can display `expired_at` in correct format for him since he can do automatic translation between his data processing layer and the credential holder. So he would not make a mistake in judging if the credential already expired.\r\n- he can display the layout and language according what he is used to in Arizona and understand all the fields even that credential was issued in German in first place. \r\n\r\nIf we think about JSON schema as over-the-wire solution, we would need take into consideration at least two layers defined above, `data capture` and `data processing` without that \"other side\" would not be able to know how to understand what s/he sees and how to process it. Unfortunately would be hard to clearly decouple those layers in JSON Schema to facilitate interoperability of the objects, multiple issuers or even to facilitate different jurisdiction of the captured data. \r\n\r\n\r\n ",
          "createdAt": "2022-03-31T10:35:52Z",
          "updatedAt": "2022-03-31T10:35:52Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "@SmithSamuelM \r\n>  I strongly object to the development of standards where the primary (reference) implementation is not at least as open as the standard spec itself.\r\n\r\n@mitfik \r\n> I think we can exclude that argument since OCA spec same as it's main reference implementation is developed under EUPL-1.2 which [definitely](https://joinup.ec.europa.eu/collection/eupl/how-use-eupl#section-2) is FLOSS license\r\n\r\nIt would be helpful to better define terms in order to resolve this argument. Historically the term \"permissive\" was used to refer to freely licensed open source (FLOSS) which usually meant that there were no downstream encumbrances on the use of the software. This typically meant that a user could embed, combine, refactor the software in new software that was proprietary. So for example Apache2, BSD, MIT were \"permissive\" and \"GPL\" or any copyLeft license was not \"permissive\". More recently the OSI (Open Software Initiative) has nuanced thier definitions of the terminology and now used the term \"reciprocal\"  and \"non-reciprocal\" instead of non-permissive and permissive (respectively) to refer to licenses that have downstream encumbrances that prevent use in proprietary software.\r\n\r\nSee the following discussion\r\n[Permissive and Copyleft Are Not Antonyms](https://opensource.org/node/875)\r\n\r\nTherefore we can better characterize the differences as: \r\nApache2 is a **_non-reciprocal_** permissive open source license.\r\nEUPL is a **_reciprocal_** permissive open source license. \r\n\r\n[EUPL Reciprocity](https://joinup.ec.europa.eu/collection/eupl/introduction-eupl-licence)\r\n> The EUPL is a reciprocal (or copyleft) licence, meaning that distributed contributions and improvements (called \"derivatives\") will be provided back or shared with the licensor and all other users. At the same time (and unlike other copyleft licences like the GPL or AGPL), the EUPL is compatible with most other open reciprocal licences and is interoperable.\r\n\r\nTherefore to clarify my argument using more up-to-date OSI terminology, I will restate it. \r\nThe primary reference implementation of an open non-reciprocal  specification should have no more restrictive reciprocity than the specification.\r\n\r\nThe reason is that implementors start with a reference implementation but if the reference implementation is reciprocal then any derivative version of an implementation that is proprietary can't use the reference implementation as a starting point. This poses an adoption barrier that is at the core of the debate between the types of open source software such as copyleft or \"reciprocal\" versus non-copyleft or non-reciprocal. \r\n\r\nTherefore OCA under EUPL is incompatible with ACDC as a normative requirement because ACDC is  fully non-reciprocal and the only implementation of OCA (HCF) is reciprocal.   \r\n\r\nThat is what I meant in the first place but I was clearly using an old definition of  permissive or freely licensed open.  \r\n\r\n",
          "createdAt": "2022-05-07T18:09:30Z",
          "updatedAt": "2022-05-07T18:18:59Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOGxcvRc5Gofs_",
      "title": "Clarified $id attribute",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/issues/7",
      "state": "CLOSED",
      "author": "mitfik",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "According to to JSON schema specification `$id` should be an URI this would make some tooling fails if we would specify `SAID` as an `$id`. \r\n\r\nNot all tools enforced that so the tools overall are not consistent neither. \r\n\r\nPotential solution:\r\n- clarify that the ACDC is not consistent with JSON Schema specification in that regards\r\n- define in ACDC that `$id` needs to be SAID schema to stay consistent with URI specification e.g. `said:Eo8uTTa8TAhXNn_hTM6b9yHK49VcH5Wh5JT5uuFu3CWk`\r\n- propose to JSON schema to allow for none URI values of the `$id` attribute",
      "createdAt": "2022-03-29T15:10:23Z",
      "updatedAt": "2022-03-31T12:37:44Z",
      "closedAt": "2022-03-31T12:37:44Z",
      "comments": [
        {
          "author": "mitfik",
          "authorAssociation": "NONE",
          "body": "Seems that we don't have to do anything on that one: \r\nhttps://datatracker.ietf.org/doc/html/rfc3986#section-4.2\r\n\r\nSAID should be easily treated as `Relative Reference` and all parser should fine with it.",
          "createdAt": "2022-03-31T11:28:50Z",
          "updatedAt": "2022-03-31T11:28:50Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOGxcvRc5GpOC7",
      "title": "Possible ambiguity of usage `oneOf` from JSON schema ",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/issues/8",
      "state": "OPEN",
      "author": "blelump",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Sam,\r\n\r\nin the spec https://github.com/SmithSamuelM/Papers/blob/master/whitepapers/ACDC_Spec.md#attribute-section there is a proposal to use `oneOf` JSON schema key attribute. To bring here the context, below is the copy pasted snippet:\r\n```\r\n\"a\": \r\n{\r\n  \"description\": \"attribute section\",\r\n  \"oneOf\":\r\n  [\r\n    {\r\n      \"description\": \"attribute SAID\",\r\n      \"type\": \"string\"\r\n    },\r\n    {\r\n      \"description\": \"uncompacted attribute section\",\r\n      \"type\": \"object\",\r\n      \"required\": \r\n      [\r\n        \"d\",\r\n        \"i\",\r\n        \"score\",\r\n        \"name\"\r\n      ],\r\n      \"properties\": \r\n      {\r\n        \"d\": \r\n        {\r\n          \"description\": \"attribute SAID\",\r\n          \"type\": \"string\"\r\n        },\r\n        \"i\": \r\n        {\r\n          \"description\": \"Issuee AID\",\r\n          \"type\": \"string\"\r\n        },\r\n        \"score\": \r\n        {\r\n          \"description\": \"test score\",\r\n          \"type\": \"integer\"\r\n        },\r\n        \"name\": \r\n        {\r\n          \"description\": \"test taker full name\",\r\n          \"type\": \"string\"\r\n        }\r\n      }\r\n    }\r\n  ]\r\n  \"additionalProperties\": false,\r\n}\r\n```\r\n\r\nI get the reasoning behind the above snippet so it's clear. What may be problematic is the `oneOf` usage by consumers. Imagine a consumer sees such an option and constructs his schema in the following way:\r\n```\r\n\"a\": \r\n{\r\n  \"description\": \"attribute section\",\r\n  \"oneOf\":\r\n  [\r\n    {\r\n      \"description\": \"plane\",\r\n      \"type\": \"object\",\r\n      \"required\":       [...      ],\r\n      \"properties\":       {       ...      },\r\n   },\r\n    {\r\n      \"description\": \"car\",\r\n      \"type\": \"object\",\r\n      \"required\":       [...      ],\r\n      \"properties\":       {       ...      },\r\n    },\r\n    {\r\n      \"description\": \"bike\",\r\n      \"type\": \"object\",\r\n      \"required\":       [...      ],\r\n      \"properties\":       {       ...      },\r\n    },\r\n  ]\r\n  \"additionalProperties\": false,\r\n}\r\n```\r\n\r\nIt is at least problematic to reason whether data is `car`, `plane` or `bike`. The `oneOf` opens context mixing for various data types. ",
      "createdAt": "2022-03-29T17:48:55Z",
      "updatedAt": "2022-04-14T02:25:51Z",
      "closedAt": null,
      "comments": [
        {
          "author": "blelump",
          "authorAssociation": "NONE",
          "body": "Found the answer in https://github.com/SmithSamuelM/Papers/blob/master/whitepapers/ACDC_Spec.md#chain-link-confidentiality-protection-with-composable-json-schema .",
          "createdAt": "2022-03-29T18:13:31Z",
          "updatedAt": "2022-03-29T18:13:31Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "Well of course any composition operator can be abused or misused or confused. That is why ACDCs are best used within an ecosystem governance framework EGF. That EGF defines the structure of the credentials that are relevant to its ecosystem. Which means that the confusion would never occur because only ACDCs that comply in structure with the EGF would be used.  But even then any pair of entities planning to engage in a transaction have to agree on what data they want to exchange within the context of that exchange.  For example, GLEIF defines its ecosystem of ACDCs, aka vLEIs. This ECF includes defining the contextual semantics and syntax for their credentials. Likewise, other  groups of issuers define the ecosystem of VCs that apply to their transaction set. Given that set, the use of `oneOf` to enable composition for the purpose of selective disclosure becomes clearly defined.\r\n\r\nWhat the ACDC spec is doing is showing how to leverage a universally adoptable set of tools like JSON Schema validators, digital signatures, and  cryptographic digests to enable selectively disclosed and chain-link confidential exchanges of data without writing that tooling from scratch. This aligns with the KERI ethos of minimally sufficient means.\r\n\r\nIt is good to remember that a universally applicable data semantic construct Is not possible. Unfortunately, this  impossibility is overlooked by many who wish for a world where such a thing is possible.  But the hard problem of **_polysemy_** and other forms of uncertainty makes this impossible. Practically speaking all data semantics are most useful within the narrow context defined by an ecosystem of transactions. The contextualized transaction set defines the applicable semantic set not the other way around.\r\n\r\nBy default every  ACDC should be structured to enable  selective disclosure for chain link confidentiality. Which means the top-level attribute block always includes a `oneOf` operator for that purpose. Within that oneOf array a given element may use a nested oneOf for other purposes. But if so, it will be clearly spelled out by the ECF for that ACDC.",
          "createdAt": "2022-03-29T22:55:25Z",
          "updatedAt": "2022-03-29T23:32:33Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "Imagine for example that some Issuer issues an ACDC that has in it an attribute labeled, \"licensed to kill\", with a value `true`.  Along with a schema that defines the type and value of the credential. What possible meaning could this credential have? The possible meanings  are unbounded. Does it mean that the identified Issuee  indeed may kill without breaking any laws?  No such simple bare construct is immune from such polysemy.\r\n\r\nIn any practical application, the credential is only understood in the context of an ecosystem that may be defined or explained by potentially hundreds or thousands of pages of documentation. These may include goverance rules and recourse rules in the event of dispute over the interpretation of that documentation.  Absent such a rich ecosystem that brings contextual meaning, bare credentials including schema are useless. The toy examples we see so often promulgated by credential technologists belie the fact that schema can not by themselves  provide sufficient contextual  meaning for decision making in the real world (i.e. actionable semantics). Credential schema provide syntactical structure that places the credential within a context but the schema by itself cannot define the context.  Only humans can do this. \r\n\r\nThe fiction of knowledge graphs is that they are self-contained.  The best automated reasoning tools only work within a narrowly defined context. The context must always be encompassed by humans who supervise its activities. A knowledge graph is just another form of automated reasoning. It must be supervised. The only intelligence we know of that can practically speaking solve the polysemy problem is a human and most humans do so very poorly. That why we have human recourse mechanisms.",
          "createdAt": "2022-03-29T23:39:52Z",
          "updatedAt": "2022-03-30T00:04:24Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "Another way of looking at polysemy is from mathematical logic.  https://en.wikipedia.org/wiki/G\u00f6del%27s_incompleteness_theorems\r\n\r\nG\u00f6del's incompleteness theorem when applied to a knowledge graph means that no knowledge graph can be self-contained. There must be an axiomatic context outside the graph that cannot be expressed in or by the graph itself. There  is not recursively defined completeness of any logical system. This is due to something called syntactic incompleteness. Given a set of axioms by which a set of rules may be expressed, those rules may be semantically complete, i.e well defined with respect to the axioms, but the set of semantic rules are incapable of expressing the axioms that the rules depend on.  \r\n\r\nAdding  the complexity of polysemy in the meaning of the set language itself only compounds the problem of incompleteness.  ",
          "createdAt": "2022-03-30T00:34:49Z",
          "updatedAt": "2022-03-30T00:43:43Z"
        },
        {
          "author": "blelump",
          "authorAssociation": "NONE",
          "body": "Thanks @SmithSamuelM .\r\n\r\nCould you elaborate on this comment https://github.com/trustoverip/tswg-acdc-specification/issues/8#issuecomment-1082447787 , especially on the first paragraph there: \r\n```\r\n[...] Likewise, other groups of issuers define the ecosystem of VCs that apply to their transaction set. \r\nGiven that set, the use of oneOf to enable composition for the purpose of selective disclosure becomes clearly defined.\r\n```\r\n\r\nIn particular, how does the `oneOf` address various transaction sets mentioned there? Assuming given EGF utilizes vLEI's, other VC's, how does `oneOf` help here?\r\n\r\nIn the spec https://github.com/SmithSamuelM/Papers/blob/master/whitepapers/ACDC_Spec.md#composable-json-schema , the `oneOf` is introduced to support the chain-link confidentiality. The `oneOf` proposes either compact or full schema. How disclosing full schema may harm the discloser in the first place? ",
          "createdAt": "2022-03-30T20:12:58Z",
          "updatedAt": "2022-03-30T20:12:58Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "@blelump  Disclosing schema does not harm the discloser or disclosee. The problem is making commitments. The issuer, upstream makes a commitment to the schema by signing the ACDC that includes a reference to the schema. Because the schema is static, only one schema can be committed to.   So composable schema enable one commitment by the issuer to the fully composed schema, so that there are no security issues arising from dynamic schema, but the validator, downstream can decompose the schema to ask and answer differentiated questions about the data provided via partial, full, or selective disclosure.  It solves a problem that otherwise requires something complicated like a cryptographic accumulator to solve. ",
          "createdAt": "2022-03-30T22:03:17Z",
          "updatedAt": "2022-03-30T22:03:17Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "For example a fully compact ACDC validates against a different (decompsed schema) expression than a partially compact expression, than a fully uncompacted expression. So instead of the Issuer committing to by signing each of all the different possible deomposed variants of a schema, the Issuer only needs to sign the composed version. The validator may then decompose as needed to validate against any variant of a compact or uncompacted disclosure of the ACDC itself.",
          "createdAt": "2022-03-30T22:06:51Z",
          "updatedAt": "2022-03-30T22:06:51Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "For example, a oneOF operator to allow compact form may have nested an   anyOf composition operator would allow the attributes of a given ACDC to be disclosed in any of the 24 EU official languages by providing a composed schema that included copies of the attribute block in an anyOf array nested inside one of the oneOF blocks, where each copy had its field labels translated into each of the 24 languages. Then a validator that wants only a given language can request disclosure the attribute block that uses that particular language and verify the schema by validating against a decomposed version of the schema that removes the anyOf operator with language options and instead just has the one language the validator requires.  The issuer simultaneously commits to anyOf the variants when it commits to the composed schema. The validator gets to enforce a decomposed version. The process is secure because the Issuer commits to a single static composable schema that allows any of the variants. The ecosystem governance framework defines how validators may safely decompose and still be compliant. Its up to the validator to enforce their own compliance, as it should be and frankly  as it only can be. The issuer certainly can\u2019t enforce it.",
          "createdAt": "2022-03-30T22:12:37Z",
          "updatedAt": "2022-03-30T22:15:11Z"
        },
        {
          "author": "mitfik",
          "authorAssociation": "NONE",
          "body": "@SmithSamuelM do you have any real use cases (example of usage of `oneOf` in real life credential/acdc) where selective disclosure would be used in a way how it is described in the spec. Because I have a problem to find a situation where `oneOf` helps with `selective disclosure` of the semantic without revealing too much what is inside. \r\n\r\nWhy so:\r\n- in most of the cases semantic are public objects, means if an `issuer` creates a schema with `oneOf` he needs very strongly protect the \"undisclosed variant\" semantic so people who would not be allowed to see that part, that they would not get it in any point of time. In the same time, this semantic needs to be distributed to those who should be able to see this part. Taking into consideration that any `holder` is able to reveal that semantic publicly, what is the point of assuming even that this semantic would not be disclosed? ",
          "createdAt": "2022-03-31T07:37:40Z",
          "updatedAt": "2022-03-31T07:37:40Z"
        },
        {
          "author": "blelump",
          "authorAssociation": "NONE",
          "body": "@SmithSamuelM , to add to what Robert just said, [in this reply](https://github.com/trustoverip/tswg-acdc-specification/issues/8#issuecomment-1083677986) the `oneOf` makes sense, so that when issuer issued compacted version and validator has uncompacted version, both will verify. This is correct, but where do you see advantage of such a feature? In particular, where does it help?\r\n\r\nUnless you think about smth like:\r\n\r\n```\r\n\"a\": \r\n{\r\n  \"description\": \"attribute section\",\r\n  \"oneOf\":\r\n  [\r\n    {\r\n      \"description\": \"person\",\r\n      \"type\": \"object\",\r\n    },\r\n    {\r\n      \"description\": \"employee\",\r\n      \"type\": \"object\"\r\n   },\r\n  ]\r\n}\r\n```\r\n\r\nso that you selectively disclose only partial information about the object? In the above example, you can disclose `person` schema which contains `person` related attributed and eventually `employee` schema, which contains only the attributes about the `work environment` of this person. ",
          "createdAt": "2022-03-31T08:03:37Z",
          "updatedAt": "2022-03-31T08:03:37Z"
        },
        {
          "author": "mitfik",
          "authorAssociation": "NONE",
          "body": "> For example, a oneOF operator to allow compact form may have nested an anyOf composition operator would allow the attributes of a given ACDC to be disclosed in any of the 24 EU official languages by providing a composed schema that included copies of the attribute block in an anyOf array nested inside one of the oneOF blocks, where each copy had its field labels translated into each of the 24 languages. \r\n\r\nI don't see much of benefits using `anyOf` in translation case:\r\n- first of all, using `anyOf` in translation case feels a bit wrong, means you are committing to different `naming flavors` of the schema not different `variants of the data` set which could be there. E.g. `first_name` -> `imi\u0119` (first_name in polish) same data just differently named. Which is not against the purpose of `anyOf` just feels bad since you could have hundreds of such variation even in one language e.g. `first_name` -> `name`. Does not seems that even [Json Schema community](https://github.com/json-schema-org/json-schema-vocabularies/issues/10) thinks that way.\r\n- but the most disadvantage of such approach is that you have to know everything up front anyway. Means you could easily commit to translation by creating schema with translation embedded in the schema as additional attribute which then can be render according to the needs. In both cases you need to have custom logic to deal with it on the presentation layer anyway.\r\n\r\nIf we speak about translation use case, I think the most powerful/practical approach is to decouple `capture base` (meaning of the data/context, semantic) from `presentation layer`. What that gives us? You are able to get credential which can life way longer without need to do any revocation or reissuing it in case if new language appear. \r\n\r\nSpeaking of this example of 24 EU official languages, why if Ukraine joins UE, shall we revoke all credential and reissue them to add new language? Or it would be batter to say that credential is still valid and now there is translation \"new layer\" released in Ukrainian which is stamp by EGF and anyone can use it against those specific credential. \r\nAnother advantage of such approach is that you can delegate responsibility of such semantic to multiple issuers where one can be responsible for `capture base` and others for `presentation layers`. ",
          "createdAt": "2022-03-31T08:08:41Z",
          "updatedAt": "2022-03-31T08:08:41Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "It depends on if you care about selective disclosure and correlation across presentation contexts. The language translation example may not be the best example for that. But it does point out that there is a difference and understanding that difference is important.  I agree that if one issues a credential that one wants to have unbounded dynamic ability to retranslate in the future, that the selective disclosure use does not solve that problem. But passports and drivers licenses are not issued indefinately so the problem is not anytime in the future but anytime in the next 5 or 10 years.  I think you are missing the point that we need to be able to do things in a cryptographically secure way for security and or correlation minimization that has harder constraints.   You can wait indefinately to solve these hard constraints or you can solve them now with tooling you have now.  You can layer OCA above ACDCs. Treat ACDCs as proof of authorship and proof of authority at a lower layer. What is proven can be an undifferentiated blob from the perspective of prooving authorship or prooving authority. You just need a digest of the blob to be in the ACDC. Then you can explode that blob and process it as OCA but refer back to the ACDC as your proof. You can store the ACDC to provide proof of authorship and proof of authority at rest vis-a-vis the layers that sit on top of it.",
          "createdAt": "2022-03-31T17:10:04Z",
          "updatedAt": "2022-03-31T17:10:04Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "Part of the problem in these discussions is that you want to push OCA before its ready and before the tooling is ready. And we NEED to deliver vLEIs built on ACDCs now. So its just too soon to be having these discussions. We committed as a community to JSON Schema months ago. So although I appreciate having a broader discussion its not timely.",
          "createdAt": "2022-03-31T17:13:57Z",
          "updatedAt": "2022-03-31T17:13:57Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "We are using JSON Schema Tooling to provide a limited degree of flexibility and extensibility in ACDCs to enable chaining and basic use cases.  A future version of ACDC could use other mechanisms such as OCA but that is a much bigger lift and bigger question so its seems entirely out of place to even introduce or suggest OCA instead of JSON Schema at this point in time.",
          "createdAt": "2022-03-31T17:16:22Z",
          "updatedAt": "2022-03-31T17:16:43Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "So please keep the discussion focused on how we can leverage JSON Schema to accomplish the version 1, features of ACDCs. And not keep suggesting we use OCA.",
          "createdAt": "2022-03-31T17:17:24Z",
          "updatedAt": "2022-03-31T17:17:41Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "> in most of the cases semantic are public objects, means if an issuer creates a schema with oneOf he needs very strongly protect the \"undisclosed variant\" semantic so people who would not be allowed to see that part, that they would not get it in any point of time. In the same time, this semantic needs to be distributed to those who should be able to see this part. Taking into consideration that any holder is able to reveal that semantic publicly, what is the point of assuming even that this semantic would not be disclosed?\r\n\r\nLet's not confuse syntax with semantics. Just because JSON and JSON Schema use the same syntax does not make them the same !.  It is very easy to confuse field labels with semantics versus correlatable values. One of the attractive reasons of using   (label, value) tuple in a field map is that one can infer semantics from a descriptive label without needing a separate schema. This is because absent a separate schema a descriptive label may convey semantics in and of itself.\r\n\r\n But is a very weak form of semantics. When we are explicitly using schema for semantics then the primary purpose of a field label is syntactical, to identify a field, to distinguish it from some other field. To clarify, when using separated schema as type information (aka semantics) the semantics of the field is not conveyed by the field label, the semantics is conveyed by the specific sub-schema identified by the syntactical element that is the field label. \r\n\r\nSo either we mix semantics and syntax by not having schema at all, or we cleanly separate the semantics in the separated schema and let the schema be the semantics. This means that field labels are syntactical elements that may leak correlatable information.\r\n\r\nSo if I care about correlating field labels across presentation contexts because the language of the field label leaks information about the context in which I present. Such as how many different places in Europe did I present my PII contained in my passport then I want to minimize the correlation of field labels as syntactical elements.   So the field labels matter in this case.  If I don't care about correlating to field labels then I make them fully public and not selectively presentable.  \r\n\r\nSo I completely agree that in most cases correlating language may not be important. But I used a trickly example to illustrate that when we care about leaking correlatable information, language is correlatable to place and therefore may be a concern when protecting against unpermissioned exploitation. It also illustrates the common misconception that field labels  in ACDC are primarily semantics when indeed they are primarily syntax. The selective disclosure mechanism for ACDC hides (blinds) the  field labels behind a cryptographically secure digest. This allows a presenter to not leak information via syntax (aka field labels).\r\n\r\n```json\r\n\"a\":\r\n[\r\n  {\r\n    \"d\": \"ErzwLIr9Bf7V_NHwY1lkFrn9y2PYgveY4-9XgOcLxUde\",\r\n    \"u\": \"0AqHcgNghkDaG7OY1wjaDAE0\",\r\n    \"i\": \"did:keri:EpZfFk66jpf3uFv7vklXKhzBrAqjsKAn2EDIPmkPreYA\"\r\n  },\r\n  {\r\n    \"d\": \"ELIr9Bf7V_NHwY1lkgveY4-Frn9y2PY9XgOcLxUderzw\",\r\n    \"u\": \"0AG7OY1wjaDAE0qHcgNghkDa\",\r\n    \"score\": 96\r\n  },\r\n  {\r\n    \"d\": \"E9XgOcLxUderzwLIr9Bf7V_NHwY1lkFrn9y2PYgveY4-\",\r\n    \"u\": \"0AghkDaG7OY1wjaDAE0qHcgN\",\r\n    \"name\": \"Jane Doe\"\r\n  }\r\n]\r\n```\r\n\r\nwith semantics\r\n\r\n\r\n~~~json\r\n\"a\": \r\n{\r\n  \"description\": \"attribute section\",\r\n  \"oneOf\":\r\n  [\r\n    {\r\n      \"description\": \"attribute section SAID\",\r\n      \"type\": \"string\"\r\n    },\r\n    {\r\n      \"description\": \"attribute details\",\r\n      \"type\": \"array\",\r\n      \"uniqueItems\": true,\r\n      \"items\": \r\n      {\r\n        \"anyOf\":\r\n        [\r\n          {\r\n            \"description\": \"issuer attribute\",\r\n            \"type\": \"object\",\r\n            \"properties\":\r\n            \"required\":\r\n            [\r\n              \"d\",\r\n              \"u\",\r\n              \"i\"\r\n            ],\r\n            \"properties\":\r\n            {\r\n              \"d\": \r\n              {\r\n                \"description\": \"attribute SAID\",\r\n                \"type\": \"string\"\r\n              },\r\n              \"u\": \r\n              {\r\n                \"description\": \"attribute UUID\",\r\n                \"type\": \"string\"\r\n              },\r\n              \"i\": \r\n              {\r\n                \"description\": \"issuer SAID\",\r\n                \"type\": \"string\"\r\n              },\r\n            },\r\n            \"additionalProperties\": false\r\n          },\r\n          {\r\n            \"description\": \"score attribute\",\r\n            \"type\": \"object\",\r\n            \"properties\":\r\n            \"required\":\r\n            [\r\n              \"d\",\r\n              \"u\",\r\n              \"score\"\r\n            ],\r\n            \"properties\":\r\n            {\r\n              \"d\": \r\n              {\r\n                \"description\": \"attribute SAID\",\r\n                \"type\": \"string\"\r\n              },\r\n              \"u\": \r\n              {\r\n                \"description\": \"attribute UUID\",\r\n                \"type\": \"string\"\r\n              },\r\n              \"i\": \r\n              {\r\n                \"description\": \"score value\",\r\n                \"type\": \"integer\"\r\n              },\r\n            },\r\n            \"additionalProperties\": false\r\n          },\r\n          {\r\n            \"description\": \"name attribute\",\r\n            \"type\": \"object\",\r\n            \"properties\":\r\n            \"required\":\r\n            [\r\n              \"d\",\r\n              \"u\",\r\n              \"name\"\r\n            ],\r\n            \"properties\":\r\n            {\r\n              \"d\": \r\n              {\r\n                \"description\": \"attribute SAID\",\r\n                \"type\": \"string\"\r\n              },\r\n              \"u\": \r\n              {\r\n                \"description\": \"attribute UUID\",\r\n                \"type\": \"string\"\r\n              },\r\n              \"i\": \r\n              {\r\n                \"description\": \"name value\",\r\n                \"type\": \"string\"\r\n              },\r\n            },\r\n            \"additionalProperties\": false\r\n          }\r\n        ]      \r\n      }\r\n    }\r\n  ]\r\n  \"additionalProperties\": false,\r\n}\r\n~~~\r\n\r\n\r\nThe array mechanism with anyOf is intentional because it enables the property that the  field labels used in a given selective disclosure are also selectively disclosed. This provides herd privacy by default to field labels. It matters not that the set of field labels appears as a set in the public composed schema. They are merely a set of optional syntactic elements. Their appearance as a set does not indicate which members of the set of syntactic elements were actually used in the presentation. This is the essence of selective disclosure, to unbundle the members of a set which set was committed too by the issuer but the actual members disclosed is committed to by the presenter.  A correlater can't correlate from the public schema what was presented across different contexts. \r\n\r\nThese tricky issues about security and privacy especially with regards semantics and syntax are hard to isolate. I am not surprised that it gets confused. Hopefully the design of ACDCs is not so confused.\r\n\r\n",
          "createdAt": "2022-03-31T17:35:28Z",
          "updatedAt": "2022-03-31T18:07:02Z"
        },
        {
          "author": "blelump",
          "authorAssociation": "NONE",
          "body": "@SmithSamuelM ,\r\n\r\nthe usage of `anyOf` basically imposes on the schema designer that whatever selective disclosure will be available on this schema in the future , it must be designed upfront. So the schema designer must define all the possible branches beforehand, as it was actually already mentioned in the translations case. \r\n\r\nWhile translations are not that critical, ie. some are missing, what if the designed branches for information disclosure don't fit the actual requirements from the discloser perspective? Shall we always impose EGF first and then any eventual discloser claims simply forward to EGF?",
          "createdAt": "2022-03-31T18:52:09Z",
          "updatedAt": "2022-03-31T18:52:09Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "@blelump\r\n\r\n> so that you selectively disclose only partial information about the object? In the above example, you can disclose person schema which contains person related attributed and eventually employee schema, which contains only the attributes about the work environment of this person.\r\n\r\nYes exactly, the is the whole purpose of selective disclosure vs. partial disclosure. Selective disclosure enables the discloser to unbundle attributes from the issuer and only disclose the subset needed to enable a transaction. So if the credential includes name, address, phone number place of work, ethnicity, religion etc but only address is relevant then selective disclosure enables disclosure of the just the address without correlating to the other attributes bundled in the credential. This the primary feature of  AnonCreds1 in Sovrin/Indy. They use a cryptographic accumulator. Here we just use an aggregated blinded commitment. Which shares many of the features of a more sophisticated accumulator. We can\u2019t do range proofs like AnonCreds1 for example. But basic selective disclosure of multi-attributes in the same credential we can.",
          "createdAt": "2022-03-31T23:15:22Z",
          "updatedAt": "2022-03-31T23:18:04Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "@blelump \r\n\r\n> the usage of anyOf basically imposes on the schema designer that whatever selective disclosure will be available on this schema in the future \r\n\r\nYes off course. Except for range proofs, that is how selective disclosure works. The Issuer based on reaonable expectations can granularize the attributes in the ACDC up front. This fits many many use cases in real world applications. Except for credentials that are unbounded documents in size.  If a credential has more than a few attributes, its probably mis-designed in the first place.  Unbounded attributes are an anti-pattern for credentials.  Credentials should not be books . If so then we don\u2019t need to differentiate the elements in such a way.  Just issue a new credential adaptively as needed. The CESR-path proof provides a way to after the fact refer to a document and issue a credential on some part of a document, on demand as needed. \r\n\r\nSuch destructuring to \u201cdata-lake\u201d a document as a single ACDC is an anti-pattern for ACDC. If the pupose of the ACDC is to provides proof of authorship of the document then the document itself is a blob from the perspective of the credential. One can \u201cdata-lake\u201d the blob after the fact without impinging on the mechaniss of the ACDC.\r\n\r\nIf on the other hand the credential is a proof of authorithity, then it needs to be focused and small and tight and so shoulld only have a few fields that can be granularized ahead of time.\r\n\r\nWanting to do both at the same time is the anti-pattern. One should pick. Is it proof of authorship or proof of authoriity. If the former then the whole document does not need to be differentiated in structure. If the later then there should only ever be a few a priori well designed welll understood attributes.\r\n\r\nWe don\u2019t need to pre-structure all documents. Just provide tooling to allow on-demand issuance of credentials as situations change in the rare exceptional conditions where some new commitment needs to be made.  Chaining helps here. Chaining allows reuse of credentials. The holder of a credential can issue a new chained credential on the fly by re-chaining or treeing credentials it already has.\r\n\r\nIt is non-sensical to believe that the environment and context in which credentials are used is such that we must design for every possible contingency.  Ecosystems evolve very slowly relative to the cost of issuing new credentials as needed.  If we automate the hard parts of authenticity, which KERI does, then the cost of issuing a new credential goes to zero. Which means credentials can become much more bespoke.   The hard part of issuing credentials is the authentication up front to establish the AID. Once that is established, a simple API can be used to issue a new credentials from what ever information is at the issuers disposal.  It really depends on the ecosystem. Some ecosystems are very very slowly evolving. Some much faster. Careful design is to not over design for all ecosystems by using the most expensive approach when only some eco-systems demand it. Too much flexibility and extensibility comes at a high cost in all the tooling and maintenance etc etc.",
          "createdAt": "2022-03-31T23:30:04Z",
          "updatedAt": "2022-03-31T23:43:01Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "All that said. This discussion is off base.  Selective disclosure mechanisms in ACDC are meant to solve two corner cases. They are not the primary case. The primary us case is solved with a **_private attribute_** ACDC not a _**selectively disclosable attribute**_ ACDC.  The combination of chain-link-confidentiality on a  graph of chained private attribute ACDCs (i.e partial disclosure) is sufficient to protect privacy.  Selective disclosure (unbundling) is not needed when the use case is designed to exploit a graph of private attribute ACDCs.\r\n\r\nThe corner cases for selective disclosure ACDCs are as follows:\r\n\r\n1) Adoption vector for legacy credentials that follow the legacy paper credential anti-pattern of mixing date needed to establish authority with data not needed to establish authority. Or mixing data needed for enforcement (forensics) with data needed to establish authority.\r\n\r\n2) Multi-context use cases where mix and match of selectively disclosable attributes from a single ACDC needed to prove authority is a better fit  than a graph of private attribute ACDCs.  \r\n\r\nThe goal is for ACDCs to provide a complete solution for adoptability reason. Rarely is mix and match selective disclosure a good idea other than for legacy systems.\r\n\r\nThe use case that is being confused is the proof of authorship.  If a proof-of-authority needs to be translated and the verifier has a trusted translator, then two credentials are needed not one. The first credential is proof of authority (authorization) issued by the entity delegating that authority (such as a license or passport). The second credential is a proof of authorship by the trusted translator of the translation of the first credentail. The proof of authorship need only reference the first credential and treat the translation as a blob from the standpoint of proof of authorship. It does not need to recreate the proof of authority. So the semantics of the two are different and do not need to be mixed in the same semantic construct.\r\n\r\nAlthough a property graph allows one to mix semantic constructs because the edges have properties that can isolate sub-graphs and establish hierarchy of different types of sub-graphs in one super graph.  So a proofs-of-authority can be linked to proofs-of-authorship. Attempting to collapse or flatten the sub-graphs into one graph with undifferentiated edge/node types is entirely problematic.\r\n",
          "createdAt": "2022-04-01T00:14:20Z",
          "updatedAt": "2022-04-01T00:27:32Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "IMHO there is a fundamental disconnect in understanding between the fields of automated reasoning and what I call data-laking for lack of a similarly precise term.  Both depend on abstractions for knowledge representation. But in the former case the decision-making drives the knowledge representation whereas in the latter the ability to mix data in a lake with some type of universal semantic representation drives the knowledge representation. But the latter makes decision making more difficult not easier. So if the purpose of data laking is to support automated decision. making it seems to be largely counter productive. Automated decision making needs highly contextualized provenanced traceable metrified information, the opposite of universal decontextualized semantics. And real world decision making is ALWAYS in an environment of extreme uncertainty so any semantic construct that does not include uncertainty as a first order property is DOA for real world decision making except in very narrow contexts. Which is the antithesis of a data-lake. We want a warehouse of data buckets not a data-lake.",
          "createdAt": "2022-04-01T00:34:21Z",
          "updatedAt": "2022-04-01T00:40:58Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "What we need are systems that are hybrids. That combine uncertainty with symbolics. Pure gradient descent deep learning is not abstractable, Pure abstractions are erroneous, un-ground truthable, un-tunable.   This paper provides a history of the disconnect and contention in the machine learning world. A similar related disconnect has existed in the knowledge representation world for almost the same amount of time.   https://nautil.us/deep-learning-is-hitting-a-wall-14467/\r\n\r\nit didn\u2019t help that the semantic web ignored uncertainty entirely. This spawned a generation of technologists that felt enabled to practice without ever feeling any obligation to understand even basic concepts of reasoning under uncertainty.",
          "createdAt": "2022-04-01T01:45:27Z",
          "updatedAt": "2022-04-01T01:45:27Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "If you look at what OCA is trying to accomplish with overlays on a capture base, it has merit for providing multiple downstream processing alternatives of the capture base. But with the exception of \"sensitive data\" there is no concept of partial, full, or selective disclosure for privacy control at the time of disclosure. The idea of sensitive data is post disclosure after its too late.  One could have an overlay that extracts the rules section and applies it to an overlay for chain-link confidentiality to subsequent users of the data but there is no conception of a Ricardian contract in OCA. There is no overlay that manages uncertainty. Or graph based processing between different ACDCs. These are all missing features that overlays of a given capture base do not address. I am not trying to discredit the good work of overlays. But OCA overlay goals are not the same as what ACDCs need to do upfront.  \r\n\r\nFinally, as I have said multiple times. It would be trivial to create a one-to-one mapping between the full disclosure variant of an attribute section of an ACDC expressed in JSON together with its JSON Schema to an OCA capture base. As you know an OCA capture base is simply a map of base attribute labels and types but that uses a newly invented syntax for expressing those attribute labels  and types. So IMHO it makes perfect sense for the proponents of OCA, as an adoption vector, to leverage the existing tooling for JSON Schema by providing an adapter that maps one-to-one the ACDC attribute section expressed a JSON schema to an OCA capture base syntax. Then there is fundamental alignment between the existing ACDC spec and  future use  of ACDC attribute sections but mapped to their  OCA overlay capture base equivalents. This can happen after the fact by any verifier once disclosure has happened. It doesn't capture the relationships between ACDCs as nodes that the edges provide but it does enable overlays of any given node.\r\n\r\n But OCA does not provide compact transmission via partial disclosure, not protection via chain-link confidentiality with partial disclosure support, nor selective disclosure support, nor support of distributed property graphs needed for chaining of credentials. OCA 's principal value is as a semantic  overlay after the fact of verifiably authentic full disclosure of the attribute section not as a mechanism for such disclosure. So its fundamental purpose is clearly not the same as ACDC its only a slice. It's just a misapplication. It fits best at a  layer above ACDC. Not integral to ACDC.  It feels like shoehorning something that solves one problem well downstream data-lake enabling  semantic overlays of a given set of attributes to something it doesn't solve at all well granular chained (treed) proofs of authorship and/or authority in a correlation protecting manner of a given set of attributes. The latter is a precursor to the former.",
          "createdAt": "2022-04-01T03:08:30Z",
          "updatedAt": "2022-04-01T03:25:48Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe that it is entirely possible to combine the concept of semantic overlays with property graph based reasoning. But that is a future topic. And will take some time to develop. In the meantime we have to as the saying goes, either fish or cut bait. We need to fish not cut bait.",
          "createdAt": "2022-04-01T03:13:39Z",
          "updatedAt": "2022-04-01T03:13:39Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "To be very specific.  The capture base of an OCA is itself an overlay on the uncompacted variant of an ACDC attribute section. The OCA capture base as overlay needs a mapping function that maps its syntax to the syntax of the decomposed JSON schema that specifies the uncompacted variant of the attribute section.\r\n\r\nThis also works for selectively disclosable attribute sections. Because each selective disclosure is itself a decomposed variant. So for each decomposed variant there is a one-to-one mapping to an OCA capture base for that variant.  \r\n\r\nThis resolves all the issues of interoperability. Downstream consumers of ACDC attributes can use an OCA capture base overlay to enable other OCA overlays.",
          "createdAt": "2022-04-01T13:58:51Z",
          "updatedAt": "2022-04-01T13:58:51Z"
        },
        {
          "author": "blelump",
          "authorAssociation": "NONE",
          "body": "@SmithSamuelM \r\n\r\nfirst of all let me apologize as I was thinking `a` is about selective disclosure, where as it is about `A`. Let me also continue on this topic and share some more thoughts.Perhaps the misunderstanding of `oneOf` appliance is the consequence of having a different way of thinking. \r\n\r\n- The ACDC  `a` attribute along with `oneOf ` appliance is considered as shown [here](https://github.com/SmithSamuelM/Papers/blob/master/whitepapers/ACDC_Spec.md#composed-schema-for-both-compact-and-uncompacted-private-attribute-acdc) in the snippet. This is a mix of compacted and uncompacted schema that is basically about the same schema. What would be the use case for such an approach?\r\n- In the [Selective Disclosure](https://github.com/SmithSamuelM/Papers/blob/master/whitepapers/ACDC_Spec.md#selective-disclosure) section there is a sentence which is probably the answer to this whole issue. The sentence is `The ACDC chaining mechanism reduces the need for selective disclosure in some applications`. So to make sure this is precisely the case, let me provide an example with Identity Card or simply an ID. According to my understanding, ACDC of an ID would look like as for example [compact ACDC](https://github.com/SmithSamuelM/Papers/blob/master/whitepapers/ACDC_Spec.md#compact-public-acdc), where the `e` attribute is interesting in particular. Assume in `e`, there is an `n` that creates a relationship to a birth certificate ACDC. The birth cert ACDC contains for example name and surname attributes. So the ID ACDC is composed of, among other things, birth certificate schema. Now, when holder is being asked about the name and surname, she presents the birth cert ACDC. When for the full ID, she presents the ID ACDC. No selective disclosure needed.\r\n\r\nAside question:\r\n- why `e` does not allow for a list of nodes and instead imposes a 1:1 relationship? In the above ID example, what if the ID ACDC would have edged to more than one other ACDC's?\r\n\r\n\r\n",
          "createdAt": "2022-04-09T21:13:50Z",
          "updatedAt": "2022-04-09T21:19:50Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "@blelump \r\n\r\n> The ACDC a attribute along with oneOf appliance is considered as shown [here](https://github.com/SmithSamuelM/Papers/blob/master/whitepapers/ACDC_Spec.md#composed-schema-for-both-compact-and-uncompacted-private-attribute-acdc) in the snippet. This is a mix of compacted and uncompacted schema that is basically about the same schema. What would be the use case for such an approach?\r\n\r\nACDCs support something that in the latest version of the spec, I called \u201cgraduated disclosure\u201d. They also support something called \u201ccontractually protected disclosure\u201d. The latter \u201ccontractually protected disclosure\u201d requires a type of graduated disclosure called partial disclosure.  These are definitions specific to the ACDC nomenclature, for lack of better terminology. Partial disclosure is different from selective disclosure.  The purpose of partial disclosure is to enable full disclosure AFTER contractual protection is put in place. There are two parties in contractually protected disclosure. The first party is the Discloser (i.e. the one making the disclosure). The second party is the Disclosee (i.e. the recipient of the disclosure).  The Discloser wants to minimize the amount of information disclosed to the Disclosee until after the Disclosee has agreed (by signing) to the terms of the disclosure. The Disclosee needs proof that what the Discloser is about to disclose was actually issued by the Issuer (the Issuer may not be the same as the Discloser in a presentations). The `oneOf` composition in the schema committed too by the Issuer (not the Discloser) enables the Discloser to proof the structure of both a partial and full disclosure as committed to by the Issuer both before (partial disclosure) and after full disclosure. It is bundling a commitment to different forms of the schema that the verifier (recipient) can unbundle without requiring a separate commitment for each composition of schema.  So composition with `oneOf` is an essential property that enables contractually protected disclosure. In a very real sense, composition of schema for selective application is analogous to the  selective disclosure of attributes but it is the selective application of schema. Via composition the Issuer can bundle and make cryptographic commitments (signing) to composed schema variants, that may be securely unbundled (selectively applied) later by the presenter or verifier.\r\n\r\nOne type of contractually protected disclosure is \u201cchain-link confidentiality\u201d. This provides comprehensive privacy protection after agreement. But to achieve such comprehensive protection the potential Discloser must graduate the disclosure of information, first metadata then details. Because schema is metadata and we require schema validation both as part of partial and full disclosure we need composition of both schema, partial and full at the time of issuance not merely at the time of presentation. At the time of presentation is too late, the Issuer is no longer involved.\r\n\r\nFurthermore, because chain-link confidentiality is not just applied to the first recipient (Disclosee) of a disclosure but to all subsequent recipients (Disclosees) in a successive chain-of-disclosures. So the schema composition originally committed to by the Issuer (head of the chain) is applied to each subsequent chain-link-confidentiality exchange (offer, agree, allow) where the compact (partial schema variant of the oneOf) is used in the offer, and the full schema variant of the oneOf is used in the allow .",
          "createdAt": "2022-04-09T21:35:37Z",
          "updatedAt": "2022-04-10T14:52:28Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "@blelump \r\n\r\n> why e does not allow for a list of nodes and instead imposes a 1:1 relationship? In the above ID example, what if the ID ACDC would have edged to more than one other ACDC's?\r\n\r\nShort answer, It does. I just didn\u2019t provide any examples of such in the spec so far. I have been working on the syntax for how to combine multiple edges in the same `e` section besides a simple logical AND.  I will update the spec before the Tuesday ACDC meeting with multiple edge examples and syntax.",
          "createdAt": "2022-04-09T21:40:15Z",
          "updatedAt": "2022-04-09T21:57:36Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "@blelump \r\n\r\nYour example of using chaining to reduce the need for selective disclosure is accurate. Unfortunately there are Issuers of legacy paper credentials that do not appreciate the advantages of graphed (chained) credentials and therefore ACDCs provide a simple selective dislcosure mechanism to support those use cases of converting existing paper credentials into verifiable ones.\r\n\r\nMore important is support for contractually protected disclosure which requires graduated disclosure and composed schema. \r\n\r\nAlso compact ACDCs also rely on graduated disclosure and composed schema.\r\n",
          "createdAt": "2022-04-09T21:46:42Z",
          "updatedAt": "2022-04-09T21:46:42Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "One reason for composed schema is to reduce the complexity of presentation exchanges and schema management. A single composed schema has one SAID. Its like a master schema. Both compact (partial) and uncompacted (full) diclosure variants are included in the master using the `oneOf` composition operator. Any message in an exchange can reference the SAID of the master schema, retrieve the associated schema from a schema database, apply the master schema to any variant of the actual data presented and it will pass validation IF and ONLY IF the data presented is compatible with an allowed variant in the master composed schema. The presentation can not introduce any additional complexity. The tooling for each step of an exchange becomes simplified because the schema committed to by the Issuer is the master composed schema.\r\n\r\nSuppose as an alternative than the master schema was not a composition  using `oneOf`  but only the uncompacted  (full) variant. Obviously the presenter could construct its own compact variant on-the-fly from the master uncompacted schema, that would be semantically compatible with the master. But now the validator has to recognize that the presenter correctly contstructed an on-the-fly compatible variant. The validator has to verify that variant to ensure that it was indeed a \u201ccompatible\u201d variant. It can\u2019t trust the presenter. This extra semantic processing and verification can be complex especially because the presenter may have a virtually unlimited set of possible \u201ccompatible\u201d on-the-fly variants it may choose to construct.  These provide an attack vector where a malicious presenter may construct a variant that the validator does not correctly evaluate as compatible or incompatible as it were. This would be a type of transaction malleability attack. \r\n\r\nWhereas with the Issuer composed schema approach proposed by the ACDC specification, the presenter is not allowed to introduce on-the-fly variants that require extra logic on the behalf of the validator to evaluate as compatible. The only party doing decomposition is the validator not the presenter. The validator knows ahead of time what the Issuer master composed schema looks like and also knows what decomposed variant it wants to test for. It doesn\u2019t have to semantically be able to verify any possible decomposition, only the ones it the validatory cares about. So it can construct its own tooling to securely do that decomposition from a known fixed composed master created by the issuer. It doesn\u2019t have to do anything special to account for on-the-fly variants created by the presenter because the presenter is not allowed to do on-the-fly constuctions or decomposition. So the presenter can not do a malleability attack on the validator and importantly the validator does not have to protect itself from such an attack. Simply validating the master composed schema against any presentation by the. presenter will either validate against one of the Issuer allowed variants or it won\u2019t. Not special logic required.\r\n\r\nIndeed in many cases the Validator can simplify its own validation. It may not need to decompose the schema at all. It just needs to check for the presence of the desired attributes in the presented data after it validates the presented data against the master composed schema. If the desired attributes are present then they MUST have complied with a known variant that specified them. If they are not present then they MUST have complied with a known variant that did not include them. But in either case the presenter can only provide data that is compliant with a known variant committed to by the Issuer.  In the latter case where the expected data is not presented but the schema validates against the presented data (i.e. is using a known compact variant) then the validator KNOWS that the source of the problem is specifically that the presenter did not make the promised (offered) disclosure and the validator can then re-request it as an incomplete presentation. This simplifies the presentation logic because the response can be simplified to an error code such as incomplete disclosure. Or can include the field labels of the expected attributes that were not disclosed. But the structure the possibilities of such error responses is known a priori by the validator because any and all presentations must be compatible with one of the variants in the composed master schema othewise they would not pass the schema validaton. \r\n\r\n In the vast majority of partial disclosure cases, for well designed attributes and schema there should only be two variants at any nesting level of an attribute section field map. The compact variant with only the SAID and the uncompated version with all the full field map. If any field values are themselves field maps then each nesting level may include its own oneOf composition of the two variants, compated and uncompacted.  Then any presentation using any combination of compacted and uncompacted field maps at any level of nesting will be an allowed variant.\r\n\r\nIn the event that some custom or bespoke variant of the Issued data truly needs to be presented, but is not possible as an allowed variant of original master composed schema. then  the correct approach is for the presenter to create its own Disclosure specific bespoke ACDC. The presenter thereby become the Issuer of the ACDC with its own associated master composed schema that may include or reference attributes via an edge pointing to the original ACDC. The presenter is effectively providing the equivalent of a custom decomposed schema, but doing so in a way that does not require any different presentation validation logic complexity or tooling on the part of the validator. \r\n\r\nTo clarify, in this later approach the tooling for validation of a presentation is just the normal tooliing. The validator does not need to account for on-the-fly decompositions by the presenter of some other Issuer\u2019s schema. Instead the bepoke ACDC created by the presenter as Issuer has allowed schema variants that are validated in the normal way but satisfy the presenter\u2019s need to use a customized presentation. This makes schema presentations extensible without needing to build support for complex presentation logic. Every presentation is validated the same way. Its just validatiing a chained ACDC using only Issuer allowed variants of composed schema for each ACDC in the chain.\r\n\r\nRecall that the purpose of ACDCs is to convey proof of authorship (authenticity) and sometimes additionally proof-of-authority (authorization) via a provenaced tree of chained ACDCs of the data payload(s) so contained. Additional business logic may need to be applied to that data payload after validaton of authenticity and authority. But that additional business logic SHOULD NOT be part of the presentation logic. This breaks the layering that ACDCs are designed to provide. ACDCs act at the presentation layer of a 7 layer OSI model. Not the application layer.",
          "createdAt": "2022-04-14T01:11:50Z",
          "updatedAt": "2022-04-14T02:25:51Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOGxcvRc5G0MTh",
      "title": "Overlays approach for semantic",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/issues/9",
      "state": "OPEN",
      "author": "mitfik",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Following discussion from #6 I would like to elaborate on a topic of overlays capture architecture and what consequences it has on overall on data architecture. \r\n\r\nAs mentioned in #6 we need to address tree problems:\r\n- data capture\r\n- data processing\r\n- data presentation\r\n\r\nWhat we would like to have is:\r\n- content driven approach (no dynamic links e.g. URL etc.)\r\n- greater interoperability \r\n- allow for multi-issuer schema\r\n- re-usability of the schema\r\n- support for i18n\r\n- stable capture base schema (capture meaning in given context without enforcing too much details)\r\n- composability (being able to combine different schema and reuse them, extend etc.. Dockerfile analogy would be good)\r\n- ontology and language agnostic\r\n\r\nTo address above issues we need:\r\n- minimalistic `capture base` which can preserve context and meaning of that data within given context. To achieve that we need just `attribute identifiers` and its `basic types`. \r\n- separate layers which provides `semantic` (character encoding, format, standards, labels, information, meta information, etc.), `inputs` (conditional, entry codes, units etc.), `transformation` (mapping, masking, subset etc), `presentation` (sensitivity, layout, credential layout etc.), \r\n- content-addressable linking mechanism between `capture base` and any `overlay`\r\n- bundle identifier which can identify `capture base` and any amount of `overlays` used during `data capture` process\r\n\r\n\r\n[OCA](https://oca.colossi.network/) was designed exactly for all above due to the lack of the solutions already existing on the market. To clarify OCA is an `Architecture`, it tells you how to compose objects (and its characteristics) to achieve desire outcome. It could potentially be used with any existing language or serialization formats. \r\n\r\nIn principle `OCA` does not conflict with `JSON schema` by any mean we can easily represent OCA objects using json schema semantic. The problem is much more on the conceptual level - architectural. \r\nJSON schema was not design to deal with all above problems. Enforcing ACDC users use only JSON Schema it could steer authentic data in wrong direction and cause same problems as we experience on the `Web 2.0`. \r\n\r\nFor reference an example of capture base using OCA json serialization:\r\n\r\n```\r\n{\r\n    \"type\": \"spec/capture_base/1.0\",\r\n    \"classification\": \"GICS:45102010\",\r\n    \"attributes\": {\r\n        \"dateOfBirth\": \"Date\",\r\n        \"dateOfExpiry\": \"Date\",\r\n        \"dateOfIssue\": \"Date\",\r\n        \"documentCode\": \"Text\",\r\n        \"documentNumber\": \"Text\",\r\n        \"documentType\": \"Text\",\r\n        \"fullName\": \"Text\",\r\n        \"issuedBy\": \"Text\",\r\n        \"issuingState\": \"Text\",\r\n        \"issuingStateCode\": \"Text\",\r\n        \"nationality\": \"Text\",\r\n        \"optionalData\": \"Text\",\r\n        \"optionalDocumentData\": \"Text\",\r\n        \"optionalPersonalData\": \"Text\",\r\n        \"personalNumber\": \"Text\",\r\n        \"photoImage\": \"Binary\",\r\n        \"placeOfBirth\": \"Text\",\r\n        \"primaryIdentifier\": \"Text\",\r\n        \"secondaryIdentifier\": \"Text\",\r\n        \"sex\": \"Text\",\r\n        \"signatureImage\": \"Binary\"\r\n    },\r\n    \"flagged_attribute\": [\r\n        \"documentNumber\",\r\n        \"fullName\",\r\n        \"primaryIdentifier\",\r\n        \"secondaryIdentifier\",\r\n        \"dateOfBirth\",\r\n        \"personalNumber\",\r\n        \"placeOfBirth\",\r\n        \"optionalPersonalData\",\r\n        \"optionalDocumentData\",\r\n        \"signatureImage\",\r\n        \"photoImage\",\r\n        \"optionalData\"\r\n    ]\r\n}\r\n```\r\nFor references how other layers are linked take a look [here](https://oca.colossi.network/v1.0.0.html#overlays)\r\n\r\nHere is the same capture based represented using `JSON Schema`:\r\n```\r\n{\r\n    \"$id\": \"EPMaG1h2hVxKCZ5_3KoNNwgAyd4Eq8zrxK3xgaaRsz2M\",\r\n    \"description\": \"Capture base - JSON Schema for Passport\",\r\n    \"title\": \"Passport\",\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"classification\": \"GICS:45102010\",\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n      \"dateOfBirth\": {\r\n        \"type\": \"string\",\r\n        \"flagged_attribute\": true,\r\n        \"format\": \"date\"\r\n      },\r\n      \"dateOfExpiry\": {\r\n        \"type\": \"string\",\r\n        \"format\": \"date\"\r\n      },\r\n      \"dateOfIssue\": {\r\n        \"type\": \"string\",\r\n        \"format\": \"date\"\r\n      },\r\n      \"documentCode\": {\r\n        \"type\": \"string\"\r\n      },\r\n      \"documentNumber\": {\r\n        \"type\": \"string\",\r\n        \"flagged_attribute\": true\r\n      },\r\n      \"documentType\": {\r\n        \"type\": \"string\"\r\n      },\r\n      \"fullName\": {\r\n        \"type\": \"string\",\r\n        \"flagged_attribute\": true\r\n      },\r\n      \"issuedBy\": {\r\n        \"type\": \"string\"\r\n      },\r\n      \"issuingState\": {\r\n        \"type\": \"string\"\r\n      },\r\n      \"issuingStateCode\": {\r\n        \"type\": \"string\"\r\n      },\r\n      \"nationality\": {\r\n        \"type\": \"string\"\r\n      },\r\n      \"optionalData\": {\r\n        \"type\": \"string\",\r\n        \"flagged_attribute\": true\r\n      },\r\n      \"optionalDocumentData\": {\r\n        \"type\": \"string\",\r\n        \"flagged_attribute\": true\r\n      },\r\n      \"optionalPersonalData\": {\r\n        \"type\": \"string\",\r\n        \"flagged_attribute\": true\r\n      },\r\n      \"personalNumber\": {\r\n        \"type\": \"string\",\r\n        \"flagged_attribute\": true\r\n      },\r\n      \"photoImage\": {\r\n        \"type\": \"string\",\r\n        \"flagged_attribute\": true,\r\n        \"format\": \"binary\"\r\n      },\r\n      \"placeOfBirth\": {\r\n        \"type\": \"string\",\r\n        \"flagged_attribute\": true\r\n      },\r\n      \"primaryIdentifier\": {\r\n        \"type\": \"string\",\r\n        \"flagged_attribute\": true\r\n      },\r\n      \"secondaryIdentifier\": {\r\n        \"type\": \"string\",\r\n        \"flagged_attribute\": true\r\n      },\r\n      \"sex\": {\r\n        \"type\": \"string\"\r\n      },\r\n      \"signatureImage\": {\r\n        \"type\": \"string\",\r\n        \"flagged_attribute\": true,\r\n        \"format\": \"binary\"\r\n      }\r\n    }\r\n}\r\n```\r\n\r\nNow since JSON schema does not have build in mechanism for linking objects (e.g. linking translation in separate object, or formatting as separate object) people would define that all inline in one schema. This would cause problems to address issues mentioned at the beginning of that post. \r\n\r\nTo summarize it:\r\n\r\n| Feature | OCA  | JSON Schema |\r\n| ---------| ------------- | ------------- |\r\n| minimalistic `capture base` | Yes | Yes, but not enforced |\r\n| separate layers | Yes  | No  |\r\n| content-addressable linking mechanism | Yes | Partially - only for `$ref`, since does not support layers |\r\n| bundle identifier | Yes | No |\r\n\r\nSemantic problem is more complex then what was mentioned here. But based on Human Colossus research we found that certain characteristic is required to even try to do it right. \r\nThis is why I would suggest to expand on that matter in ACDC specification in a way that we don't limit ACDC to be able to use only `JSON schema` but define characteristic of semantic which is allowed to be used to have authentic data containers which can address mentioned issues.\r\nWe have that agility in all other aspects of ACDC, like crypto for SAID and SCID why not allow to have that on semantic as well? I get the argument that too much flexibility generate adoption issues  but without it we close the doors for huge communities which needs to address above issues and JSON Schema does not help with it. \r\n\r\nTo make that clear I am not looking for OCA adoption vectors - OCA will be fine.  I am more worry about that ACDC would be narrow use case for verifiable credential and won't be adopted outside that space. Since we already know that `JSON Schema` does not solve the problems of the data harmonization overall. The \"data\" world is way bigger then \"verifiable credential\", so I am more after ACDC adoption vectors then anything else.  \r\n\r\nhappy to hear your thoughts on that\r\n\r\n\r\n\r\n",
      "createdAt": "2022-03-31T13:32:47Z",
      "updatedAt": "2022-04-01T19:09:52Z",
      "closedAt": null,
      "comments": [
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "It would be helpful to combine this issue with the other one already opened as there is significant overlap with https://github.com/trustoverip/tswg-acdc-specification/issues/8\r\n\r\nSo I will reproduce here the answers from above that specifically address your question here.\r\n\r\n@SmithSamuelM \r\n> If you look at what OCA is trying to accomplish with overlays on a capture base, it has merit for providing multiple downstream processing alternatives of the capture base. But with the exception of \"sensitive data\" there is no concept of partial, full, or selective disclosure for privacy control at the time of disclosure. The idea of sensitive data is post disclosure after its too late. One could have an overlay that extracts the rules section and applies it to an overlay for chain-link confidentiality to subsequent users of the data but there is no conception of a Ricardian contract in OCA. There is no overlay that manages uncertainty. Or graph based processing between different ACDCs. These are all missing features that overlays of a given capture base do not address. I am not trying to discredit the good work of overlays. But OCA overlay goals are not the same as ACDC goals..\r\n\r\n@mitfik \r\n> In principle OCA does not conflict with JSON schema by any mean we can easily represent OCA objects using json schema semantic. \r\n\r\nYou have it backwards. The point is that you can represent a fully disclosed ACDC attribute section as an OCA capture base overlay of the JSON Schema of the fully disclosed ACDC attribute section.\r\n \r\n> Finally, as I have said multiple times. It would be trivial to create a one-to-one mapping between the full disclosure variant of an attribute section of an ACDC expressed in JSON together with its JSON Schema to an OCA capture base. As you know an OCA capture base is simply a map of base attribute labels and types but that uses a newly invented syntax for expressing those attribute labels and types. So IMHO it makes perfect sense for the proponents of OCA, as an adoption vector, to leverage the existing tooling for JSON Schema by providing an adapter that maps one-to-one the ACDC attribute section expressed a JSON schema to an OCA capture base syntax. Then there is fundamental alignment between the existing ACDC spec and future use of ACDC attribute sections but mapped to their OCA overlay capture base equivalents. This can happen after the fact by any verifier of an ADCD once disclosure has happened. It doesn't capture the relationships between ACDCs as nodes that the edges provide but it does enable overlays of the attributes within a given node.  \r\n\r\nThis enables all the architecture elements of OCA goodness for downstream processing of that node. This is clean compatibility in a layered sense.\r\n\r\n> But OCA does not provide compact transmission via partial disclosure, not protection via chain-link confidentiality with partial disclosure support, nor selective disclosure support, nor support of distributed property graphs needed for chaining of credentials. OCA 's principal value is as a semantic overlay after the fact of verifiably authentic full disclosure of the attribute section not as a mechanism for such disclosure. So its fundamental purpose is clearly not the same as ACDC its only a slice. It's just a misapplication. It fits best at a layer above ACDC. Not integral to ACDC. It feels like shoehorning something that solves one problem well downstream data-lake enabling semantic overlays of a given set of attributes to something it doesn't solve at all well granular chained (treed) proofs of authorship and/or authority in a correlation protecting manner of a given set of attributes. The latter is a precursor to the former.\r\n\r\n> To be very specific. The capture base of an OCA is itself an overlay on the uncompacted variant of an ACDC attribute section. The OCA capture base as overlay needs a mapping function that maps its syntax to the syntax of the decomposed JSON schema that specifies the uncompacted variant of the attribute section.\r\n\r\n> This also works for selectively disclosable attribute sections. Because each selective disclosure is itself a decomposed variant. So for each decomposed variant there is a one-to-one mapping to an OCA capture base for that variant.\r\n\r\n> This resolves all the issues of interoperability. Downstream consumers of ACDC attributes can use an OCA capture base overlay to enable other OCA overlays.\r\n\r\nSo all the goodness of OCA architecture works as an overlay. Starting with using the OCA capture base as an overlay itself of an ACDC attribute section.\r\n\r\nMore generally any ACDC could include as an attribute the SAID of an external OCA capture base.  The ACDC itself  is just making an authenticatable, authorizable commitment to that capture base via a commitment to its SAID. The actual exploded capture base can then be attached to the ACDC or cached.   The ACDC provides proof of authorship and/or proof of authority to the referenced (via SAID) capture base detail.  \r\n\r\nThus there is no incompatibility here. This provides clean layering. Clean separation of concerns. It allows ACDCs to do what they do best and allows an OCA to do what it does best. This is how the architecture should work. \r\n\r\nIn this more general approach,  the only thing that the JSON Schema of the ACDC cares about is that there is a field whose value is the SAID of an OCA capture base. The ACDC itself is a support for the OCA, literally a container that provides a authenticated disclosed comittment to an OCA capture base in one field. The container itself is opaque to the OCA capture base and any downstream processing. Likewise, the OCA capture base is opaque to the container as it should be. That is what containers are meant to be. Their payloads are opaque. So no conflict between schema compatibility. There is no need to schematize the structure of the  ACDC attribute section within the OCA other than to map the one field that includes the SAID of the OCA. This is trivial to do. There is also no need to EVER schematicise the OCA capture base inside the ACDC attribute section. The OCA structure is completely opaque to the ACDC.   \r\n\r\nThis thin layering fits the hourglass model. I have suggested this layering multiple times in these conversations, and I have yet to see a specific response that indicates any reason why this does not work. \r\n\r\nPointing out features of OCA that JSON Schema does not support for OCA overlays does not explain why using ACDC as a layer below OCA is a problem. The CONTAINER in Authentic Chained Data Containers is there for a reason. Your proposal to De-containerize an ACDC is going backwards. Its de-layering.   It feels like going in circles to me.  \r\n",
          "createdAt": "2022-04-01T16:44:27Z",
          "updatedAt": "2022-04-01T16:58:41Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "I am going to take one more pass at this in hopes to flip the switch in your mind.\r\n\r\nIn a 7 layer OSI stack, authentication usually happens at the presentation layer. The application payload is not processed until the application layer and is completely opaque to the presentation header that provides all the information needed for authentication.  ACDCs provide an analogous function to the presentation layer. The application layer is opaque to them. OCA works at the application layer not the presentation layer.  The mistake is to confuse the separation of these two layers. I am not surprised at the confusion because the W3C VC data model is confused about the separation between those two layers and that has confused the community. The reason I started ACDC was largely to restore the separation between authentication (presentation) layer that is an ACDC and the application layers that consume the payload of an ACDC.\r\n\r\nAn ACDC does not need to have a payload. It could serve the analogous role of an access token. Its pure authentication, no payload, no application layer. It is just the presentation header.\r\n\r\nOr the ACDC could have a payload which means it is a presentation header wrapper to a payload. The payload layer itself may consist of multiple layers. This is the case with OCA, but the application layer(s) MUST not be confused with the presentation layer or any other layers below the application layer.\r\n\r\nWhen the ACDC is acting as a proof-of-authorship, the proof is about the authorship of some data. The data payload could be nothing more than a SAID of the payload. This is analogous to a token that includes a hash of some other data that the token is authorizing.\r\n\r\nWhen the ACDC is acting as a proof-of-authority, then there may not be a payload either, the attributes in the ACDC itself are just syntactic sugar that characterizes the type of authority that is being proven. Or the attributes could also include a reference to a payload so that the ACDC is providing both proof-of-authority and/or proof-of-authorship about its payload.\r\n\r\nThis last use case is where the confusion sets in.  A proof-of-authorship just needs a signature (and information needed to look up the key state to verify the signature i.e. KERI)  Whereas a proof-of-authority requires some extra information besides merely a signature (and the information needed to look up the key state to verify the signature i.e. KERI). It needs information to characterize the \"authority\" or \"authorization\".  In addition to the authority characterization information, the ACDC may or may not have OTHER information that is purely payload.\r\n\r\nThis authority characterizing information is often confused with the OTHER information in the payload. \r\nIt's not. It's part of the authentication (presentation) layer. \r\n\r\n\r\nThe problem with paper credentials is that they combine multiple types of information. For example, a driver's license mixes proof-of-authority i.e. an authenticatable authorization to drive  with forensic information needed to enforce the proof-of-authority.  Downstream processing is almost always on the forensic enforcement information, not on the authorization to drive.  The former is a payload the latter is an authorization. The VC data model was influenced too strongly by the paper credential data model and ends up making the same mistake of mixing proofs of authorship/authority with payloads to which such a proof applies. (application of proof  == application layer, proof itself == presentation (authentication) layer)\r\n\r\nThe word credential in English means proof-of-entitlement permission right etc. Or as I have used here proof-of-authority to do something. The \"to do something\" is the characterization of that proof.  But historically such proofs come with Other data  not part of the proof of something.  So for example in the supply chain example. A proof-of-authority is used to authorize a trading partner to sell a given product. The proof-of-authority is not the product. The product details, its consituent parts may be attached to the proof-of-authority as a manifest i.e. the data payload is the manifest. So the OCA applies to the manifest not the proof-of-authority.  If I want to selectively disclose the manifest then the selective disclosure mechanism sits outside the manifest it is not part of the manifest itself! Is this not abundantly clear?  \r\n\r\nThink about product import documentation. There is a proof-of-tariff that authorizes the import and there is a manifest of what's inside the box being imported. Don't be confused by the fact that they are both pieces of paper. The two pieces of paper act at different layers of processing and have different purposes and different properties for processing. The fact that we have tools to model them both as documents is the problem. We succumb to the false idea that they are the same just because they are both data and can be processed with data processing tools such as schema validators. This is a dangerous  confusion and I believe to be the fundamental confusion resulting in this conversation. I am going to great lengths to disabuse you of the idea that merely because a proof-of-authority may be expressed as item of data and may be processed with data processing tools makes it the same as the payload attached to such a proof.\r\n\r\nWhen I use HTTP to send a JSON document in the body of the HTTP document. The HTTP headers , the TCP headers, the IP headers, the MAC layer headers, The ethernet headers,  are all included in the data that is sent along with the JSON Body. But it would be entirely foolish from a data modeling and functional layering perspective to assume that we should be schematizing all those headers as part of one universal schema simply because they are wrappers around the JSON body. Just because we can does not mean we should. Universality comes at a cost. Each layer is in a different trade space. The separation between layers allows granular optimization of the layered trade spaces.\r\n\r\nLikewise, an ACDC is a header to its payload or it may not have a payload in which case it is just a header. The ACDC's trade space is different than its payload's trade space.\r\nClearly,  therefore the ACDC MUST be processed in its own layer, not its payload's layer. And should optimize its tooling for its own layer not its payload's layer.\r\n\r\nOCA is designed to shape the payload for different applications of the payload in each of the OCA overlays. Think different overlay == different shape.  It is NOT designed to operate on the layer specific header data that is stripped off in all the lower layers that support the payload. Don't confuse the tool (OCA syntax) with the application of the tool.\r\n\r\nOCA  is a layered data shaping tool not a protocol layering tool. Protocol layering and data shape layering are two different types of layering. The use of the term layer in both does not make them even remotely close to being the same thing and the tooling for each has significantly different properties.\r\n\r\nI hope this flips the switch.\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2022-04-01T17:12:02Z",
          "updatedAt": "2022-04-01T19:09:52Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOGxcvRc5G5Z4Q",
      "title": "Mentioning GLEIF as major use case for ACDC's",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/issues/10",
      "state": "OPEN",
      "author": "blelump",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi Sam,\r\n\r\nin the spec [intro](https://github.com/SmithSamuelM/Papers/blob/master/whitepapers/ACDC_Spec.md#introduction) you mention GLEIF as primary major use case for the proposed spec. Furthermore there are other mentions to VC's, DID's and so on.\r\n\r\n1. Shall the spec favor one use case (GLEIF) specifically by explicitly mentioning it where it'll be primarily applied? The spec itself is definitely more than that and as `major use case` doesn't exclude other use cases, it somehow favor this one. Other than that the lifetime of the spec may be far beyond the aforementioned use case, therefore may not be valid anymore.\r\n2. Shall the spec reflect to other existing techies like VC/DID as opposed to be an alternative approach, proposing it's own way to solve the underlying problem? The adoption of both (VC/DID) is unclear yet, therefore it's not known where and how it'll end up.",
      "createdAt": "2022-04-01T08:35:18Z",
      "updatedAt": "2022-04-01T13:29:55Z",
      "closedAt": null,
      "comments": [
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "1) The mention of GLEIF is not meant to favor it but to illustrate a major adoption use case. This provides informative context\r\n2) Its not clear where the w3c VC spec will end up. Discussions of VC version 2.0 indicate a bigger tent approach. So I did not include that discussion in the ACDC spec itself as it is not so relevant to the spec. But given that most people who are interacting with ACDC have some familiarity with some version of the VC spec, pointing out differences is informative.\r\n\r\nI am open to suggestions on how better to include informative versus normative information in the spec.",
          "createdAt": "2022-04-01T13:29:54Z",
          "updatedAt": "2022-04-01T13:29:54Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "I_kwDOGxcvRc5HOB0F",
      "title": "Adding Support for Logical Connectives (Operators) on Edges",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/issues/46",
      "state": "OPEN",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The Simple Grant Language, https://github.com/evernym/sgl is a Domain Specific Language for granting privileges (authorizations) conveyed by verifiable credentials. It includes logical operations such as AND OR etc connectives.\r\n\r\nACDC supports property graphs (PG) which include edges with properties. A common use case for a property graph is to aggregate edges. For example, weighted edges can be used with many decision making algorithms such as multi-attribute decision making where the aggregation of a set of weighted values is used to calculate the final decision. \r\n\r\nIn general, we can define aggregation operations over a set of edges for general decision making logic on the set of edges. A tree of such aggregations then becomes a hierarchical decision tree.   With such trees we can reproduce much of the logic of a DSL like SGL (simple grant language).  \r\n\r\nOne of the early use cases is to address the logic for validating an ACDC with more than one edge. Does the ACDC only validate if both edges,  validate (\"AND\" logic aggregate) , or does the ACDC validate if either edge validates (\"OR\" logic aggregate).  \r\n\r\nI suggest that the default, is \"AND\" logic aggregate which is the safest. But then how to specifiy some aggregate that is not the default.\r\n\r\nFor these we need to specify the syntax for weighting edges with some common aggregation operators such as AND, OR and maybe even logical negation, NOT. as in a credential is valid only if a chained credential is NOT valid.\r\n\r\nThis issue is a place holder for suggestions for the syntax of aggregation within the edge section of an ACDC.",
      "createdAt": "2022-04-06T16:43:10Z",
      "updatedAt": "2022-04-11T19:51:16Z",
      "closedAt": null,
      "comments": [
        {
          "author": "pfeairheller",
          "authorAssociation": "NONE",
          "body": "Trying to work out how this would look using the vLEI OOR credential as an example (leaving out the rules section for brevity).  As described here, the default of AND makes that case pretty straight forward and solves the \"chain of trust\" issue with the current schema.  So we would add the QVI credential as a direct descendant of the OOR as follows:\r\n\r\n```\r\n{\r\n  \"v\": \"ACDC10JSON00011c_\",\r\n  \"d\": \"E1qH1E2zo7rnW1Pwm3NuYOXZ1SsVH3yeV2Iifj2wtCgA\",\r\n  \"i\": \"did:keri:EZBfSGG5k1CZYk1QH3GXFPtEwLHf0H06zuDUEJRyar1E\",\r\n  \"ri\": \"did:keri:EymRy7xMwsxUelUauaXtMxTfPAMPAI6FkekwlOjkggt\",\r\n  \"s\": \"EDg-Ji3kmi_G97Jctxeajpmp1-A8gSpeyElm-XCzTxiE\",\r\n  \"a\": {\r\n    \"d\": \"ErmVM5JGLewHJrSqIuhwWktoIlfffh7sHIGAQvtcFSU\",\r\n    \"i\": \"did:keri:E70sYPRHygB9aOzgg_xEbI5RCVyRRCAXWG9uHyRNrqYE\",\r\n    \"dt\": \"2021-06-09T17:35:54.169967+00:00\",\r\n    \"LEI\": \"254900YH3ZCDPE1E5306\",\r\n    \"personLegalName\": \"John Smith\",\r\n    \"officialRole\": \"Chief Executive Officer\"\r\n  },\r\n  \"e\": {\r\n    \"d\": \"EBDmgKOAEwnMGsofWg2m0l63J1awfJafqJyCzTnVkdSw\",\r\n    \"legalEntityvLEICredential\": {\r\n      \"n\": \"Et2DOOu4ivLsjpv89vgv6auPntSLx4CvOhGUxMhxPS24\"\r\n    },\r\n    \"qualifiedvLEIIssuervLEICredential\": {\r\n      \"n\": \"Et2DOOu4ivLsjpv89vgv6auPntSLx4CvOhGUxMhxPS24\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nUsing the default logic of AND between sibling nodes, this would work.  To change that to an \"OR\" we could group the siblings under an \"or\" label as follows:\r\n\r\n```\r\n{\r\n  \"v\": \"ACDC10JSON00011c_\",\r\n  \"d\": \"E1qH1E2zo7rnW1Pwm3NuYOXZ1SsVH3yeV2Iifj2wtCgA\",\r\n  \"i\": \"did:keri:EZBfSGG5k1CZYk1QH3GXFPtEwLHf0H06zuDUEJRyar1E\",\r\n  \"ri\": \"did:keri:EymRy7xMwsxUelUauaXtMxTfPAMPAI6FkekwlOjkggt\",\r\n  \"s\": \"EDg-Ji3kmi_G97Jctxeajpmp1-A8gSpeyElm-XCzTxiE\",\r\n  \"a\": {\r\n    \"d\": \"ErmVM5JGLewHJrSqIuhwWktoIlfffh7sHIGAQvtcFSU\",\r\n    \"i\": \"did:keri:E70sYPRHygB9aOzgg_xEbI5RCVyRRCAXWG9uHyRNrqYE\",\r\n    \"dt\": \"2021-06-09T17:35:54.169967+00:00\",\r\n    \"LEI\": \"254900YH3ZCDPE1E5306\",\r\n    \"personLegalName\": \"John Smith\",\r\n    \"officialRole\": \"Chief Executive Officer\"\r\n  },\r\n  \"e\": {\r\n    \"d\": \"EBDmgKOAEwnMGsofWg2m0l63J1awfJafqJyCzTnVkdSw\",\r\n    \"or\": {\r\n      \"legalEntityvLEICredential\": {\r\n        \"n\": \"Et2DOOu4ivLsjpv89vgv6auPntSLx4CvOhGUxMhxPS24\"\r\n      },\r\n      \"qualifiedvLEIIssuervLEICredential\": {\r\n        \"n\": \"Et2DOOu4ivLsjpv89vgv6auPntSLx4CvOhGUxMhxPS24\"\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\nAgain, this seems pretty straightforward to understand and implement.  \r\n\r\n\"NOT\" is a little trickier, but we could collect single siblings under a \"not\" label to negate it against any siblings of the \"not\" label.  For example:\r\n\r\n```\r\n{\r\n  \"v\": \"ACDC10JSON00011c_\",\r\n  \"d\": \"E1qH1E2zo7rnW1Pwm3NuYOXZ1SsVH3yeV2Iifj2wtCgA\",\r\n  \"i\": \"did:keri:EZBfSGG5k1CZYk1QH3GXFPtEwLHf0H06zuDUEJRyar1E\",\r\n  \"ri\": \"did:keri:EymRy7xMwsxUelUauaXtMxTfPAMPAI6FkekwlOjkggt\",\r\n  \"s\": \"EDg-Ji3kmi_G97Jctxeajpmp1-A8gSpeyElm-XCzTxiE\",\r\n  \"a\": {\r\n    \"d\": \"ErmVM5JGLewHJrSqIuhwWktoIlfffh7sHIGAQvtcFSU\",\r\n    \"i\": \"did:keri:E70sYPRHygB9aOzgg_xEbI5RCVyRRCAXWG9uHyRNrqYE\",\r\n    \"dt\": \"2021-06-09T17:35:54.169967+00:00\",\r\n    \"LEI\": \"254900YH3ZCDPE1E5306\",\r\n    \"personLegalName\": \"John Smith\",\r\n    \"officialRole\": \"Chief Executive Officer\"\r\n  },\r\n  \"e\": {\r\n    \"d\": \"EBDmgKOAEwnMGsofWg2m0l63J1awfJafqJyCzTnVkdSw\",\r\n    \"not\": {\r\n      \"legalEntityvLEICredential\": {\r\n        \"n\": \"Et2DOOu4ivLsjpv89vgv6auPntSLx4CvOhGUxMhxPS24\"\r\n      }\r\n    },\r\n    \"qualifiedvLEIIssuervLEICredential\": {\r\n      \"n\": \"Et2DOOu4ivLsjpv89vgv6auPntSLx4CvOhGUxMhxPS24\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nFrom this basic approach I believe we could achieve any level of complexity with simple nesting.  Is this the approach you are thinking of?",
          "createdAt": "2022-04-07T12:24:33Z",
          "updatedAt": "2022-04-07T12:24:33Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "I like how compact the representation is as a result of overloading labels as operators. My concern is that operators become reserved tokens inside the edge label space. The number of potential operators could be large.  (implication, sum, avg, etc). The literature on automated reasoning, multi-constraint, multi-objective etc includes dozens of aggregation operators.\r\nOthewise we could always nest so the default is not possible and must be `and`.  Then there are two namespaces. One for operators at the top level and then the next level down are edge labels. Then we would have alternating layers of operator labels and edge labels for trees of branched operators aggregations.\r\n\r\nAlternative If we just reserve one label, such as, 'o' for operator then its value is unconstrained and does not materially collide with the label space for edges. We would have then only  `d` and `o` as reserved labels in the edge label space.  To nest then we have a group  `g`,  label and then inside the group block is an `o` field and then edges. This saves us from having to nest two layers (one for operator and one for edge). Anyway haven't dug into alternatives. This removes half the layers since there are not two layers for each aggregate but only one.  But don't have an opinion yet. But maybe two layers one for operators and one for edges is logically cleaner eve if more verbose.",
          "createdAt": "2022-04-07T17:31:44Z",
          "updatedAt": "2022-04-07T17:52:15Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "# Proposed Operators\r\n\r\nAfter some thought and reviewing your suggestions. Here is a modified proposal.\r\nFirst some definitions then some examples\r\n\r\n## Definitions\r\n### Label Types  \r\nThere are three types of labels:\r\n\r\n* Reserved Field Labels (Metadata).\r\n  `d` for SAID of block\r\n  `o` for operator\r\n  `n` for Node SAID (another ACDC)\r\n  `w` for weight\r\n\r\n* Edge Field Map Labels (Single Edges)\r\n   any value except reserved values above\r\n\r\n* Edge-Group Field Map Labels (Aggregates of Edges)\r\n  any value except reserved values above\r\n\r\n# Block Types\r\n\r\nThere are two types of field-maps or blocks that may appears as  values of fields within an edge section, `e`, field either at the top level or nested:\r\n\r\n* Edge-Group. An _**edge-group**_ MUST NOT have a node,  `n`,  metadata field. Its non-metadata field values may include other (sub) edge-group blocks, edge blocks or other properties.\r\n\r\n* Edge. An _**edge**_ MUST have a node, `n`,  metadata field. Its non-metadata field values MUST NOT include edge-group blocks or other edge blocks but may include other types of properties. From a graph perspective, _edge_ blocks terminate at their node, `n`, field and are not themselves nestable. An _edge_ block is a  leaf with respect to any nested _edge-group_ blocks in which the edge appears. It is therefore  also a leaf with respect to its enclosing top-level edge section, `e`, field.  The ACDC node that an edge points to may have its own edge-groups or edges in that node's own top-level edge section.\r\n\r\nThe top-level edge section, `e`, field value is always an _edge-group_ block.\r\n\r\nWith respect to the granularity of a property graph consisting of ACDCs as nodes, nested edge-groups within a given top-level edge field, `e`, field of a given ACDC constitute a  sub-graph whose nodes are edge-groups not ACDCs. One of the attractive features of property graphs (PGs) is their support for different edge and node types which enables nested sub-graphs such as is being employed here to support the expression of complex logical or aggregative operations on groups of edges (as subnodes) within the top-level edge section, `e`, field of an ACDC (as supernode).\r\n\r\n### Operator, `o`,  Field\r\n\r\nThe meaning of the operator, `o`, metadata field label depends on which type of block it appears in.\r\n\r\n* When appearing in an edge-group block then the operator, `o`, field value is an aggregating (m-ary) operator, such as, `OR`, `AND`, `AVG`, `NAND`, `NOR`  etc. Its operator applies to all the edges  or edge-groups that appear in that edge-group block.\r\n\r\n* When appearing in an edge block then the operator, `o`,  field value is a unary operator like `NOT`.  When more than one unary operator applies to a given edge then the value of the operator, `o`, field is a list of those unary operators.\r\n\r\n### Weight, `w`, field.\r\nMany aggregating operators used for automated reasoning such as weighted average, `WAVG`, or ranking aggregation, depends on each edge having a weight. To simplify the semantics for such operators, the weight, `w`, field is the reserved field label for weighting. Other fields could provide other types of weights but having a default simplifies the default definitions of those weighted operators. \r\n\r\n### Special Unary Operators\r\n\r\nTwo special unary operators are defined for ACDCs. These are:\r\n\r\nIssuer-To-Issuee, `I2I`, constraint operator\r\nand \r\nNot-Issuer-To-Issuee, `NI2I`, constraint operator\r\n\r\nMany ACDC chains use targeted ACDCs (i.e. have Issuees). A chain of Issuer-To-Issuee targeted ACDCs in which each Issuee becomes the Issuer of the next ACDC in the chain can be used to provide a chain-of-authority. A common use case of a chain-of-authority is a delegation chain for authorization.  \r\n\r\nThe `I2I` unary operator when present means that that the Issuee of the node that the edge points to MUST be the Issuer of the current ACDC in which the edge resides. This also means therefore that the ACDC node pointed to by the edge must also be a targeted ACDC.\r\n\r\nThe `NI2I` unary operator when present removes or nullifies any requirement expressed by the dual `I2I` operator descibed above. In other words any requirement that the Issuee of the node the edge points to MUST be the Issuer of the current ACDC in which the edge resides is not applicable. To clarify, when operative (present), the `NI2I` operator means that a targeted ACDC as node of the associated edge may still be valid even when the Issuee of that node's ACDC is not the Issuer of the ACDC in which the edge appears. Furthermore, the ACDC node pointed to by the edge may or may not be a targeted ACDC.\r\n\r\nIf both the `I2I` and `NI2I` operators appear in an operator, `o`, field list then the last one appearing in the list is the operative one.\r\n\r\n## Defaults for missing operators\r\n\r\nWhen the operator, `o`,  field is missing in an edge-group block.\r\nThe default value for the operator, `o`, field  is `AND`.\r\n\r\nWhen the operator, `o`, field is missing or empty in an edge block, or is present but does not include either the `I2I` or `NI2I` operators Then:\r\n\r\nIf the node pointed to by the edge is a targeted ACDC i.e. has an Issuee, by default it is assumed that the `I2I` operator is appended to the operator, `o`, field's effective list value.  \r\n\r\nIf the node pointed to by the edge-block is a non-targeted ACDC i.e. does not have an Issuee, by default, it is assumed that the `NI2I` operator is appended to the operator, `o`, field's effective list value.  \r\n\r\n## Examples\r\n\r\n### Defaults\r\n~~~json\r\n{\r\n  \"e\": \r\n  {\r\n    \"d\": \"EerzwLIr9Bf7V_NHwY1lkFrn9y2PgveY4-9XgOcLx,UdY\",\r\n    \"boss\":\r\n    {\r\n      \"n\": \"EIl3MORH3dCdoFOLe71iheqcywJcnjtJtQIYPvAu6DZA\",\r\n      \"power\": \"high\"\r\n    }\r\n   \"baby\":\r\n    {\r\n      \"n\": \"EORH3dCdoFOLe71iheqcywJcnjtJtQIYPvAu6DZAIl3A\",\r\n      \"power\": \"low\"\r\n    }\r\n  }\r\n}\r\n~~~\r\n\r\n### Explicit AND\r\n~~~json\r\n{\r\n  \"e\": \r\n  {\r\n    \"d\": \"EerzwLIr9Bf7V_NHwY1lkFrn9y2PgveY4-9XgOcLx,UdY\",\r\n    \"o\": \"AND\",\r\n    \"boss\":\r\n    {\r\n      \"n\": \"EIl3MORH3dCdoFOLe71iheqcywJcnjtJtQIYPvAu6DZA\",\r\n      \"power\": \"high\"\r\n    }\r\n   \"baby\":\r\n    {\r\n      \"n\": \"EORH3dCdoFOLe71iheqcywJcnjtJtQIYPvAu6DZAIl3A\",\r\n      \"o\": \"NOT\",\r\n      \"power\": \"low\"\r\n    }\r\n  }\r\n}\r\n~~~\r\n\r\n### Unary I2I\r\n\r\n~~~json\r\n{\r\n  \"e\": \r\n  {\r\n    \"d\": \"EerzwLIr9Bf7V_NHwY1lkFrn9y2PgveY4-9XgOcLx,UdY\",\r\n    \"o\": \"AND\",\r\n    \"boss\":\r\n    {\r\n      \"n\": \"EIl3MORH3dCdoFOLe71iheqcywJcnjtJtQIYPvAu6DZA\",\r\n       \"power\": \"high\"\r\n    }\r\n    \"baby\":\r\n    {\r\n      \"n\": \"EORH3dCdoFOLe71iheqcywJcnjtJtQIYPvAu6DZAIl3A\",\r\n      \"o\": \"I2I\",\r\n      \"power\": \"low\"\r\n    }\r\n  }\r\n}\r\n~~~\r\n\r\n### Unary NI2I\r\n\r\n~~~json\r\n{\r\n  \"e\": \r\n  {\r\n    \"d\": \"EerzwLIr9Bf7V_NHwY1lkFrn9y2PgveY4-9XgOcLx,UdY\",\r\n    \"o\": \"OR\",\r\n    \"boss\":\r\n    {\r\n      \"n\": \"EIl3MORH3dCdoFOLe71iheqcywJcnjtJtQIYPvAu6DZA\",\r\n      \"o\": \"NI2I\",\r\n      \"power\": \"high\"\r\n    }\r\n    \"baby\":\r\n    {\r\n      \"n\": \"EORH3dCdoFOLe71iheqcywJcnjtJtQIYPvAu6DZAIl3A\",\r\n      \"o\": \"I2I\",\r\n      \"power\": \"low\"\r\n    }\r\n  }\r\n}\r\n~~~\r\n\r\n\r\n### Nested Edge-Group\r\n~~~json\r\n{\r\n  \"e\": \r\n  {\r\n    \"d\": \"EerzwLIr9Bf7V_NHwY1lkFrn9y2PgveY4-9XgOcLx,UdY\",\r\n    \"o\": \"AND\",\r\n    \"boss\":\r\n    {\r\n      \"n\": \"EIl3MORH3dCdoFOLe71iheqcywJcnjtJtQIYPvAu6DZA\",\r\n      \"o\": [\"NI2I\", \"NOT\"],\r\n      \"power\": \"high\"\r\n    }\r\n    \"baby\":\r\n    {\r\n      \"n\": \"EORH3dCdoFOLe71iheqcywJcnjtJtQIYPvAu6DZAIl3A\",\r\n      \"o\": \"I2I\",\r\n      \"power\": \"low\"\r\n    }\r\n    \"food\":\r\n    {\r\n      \"o\": \"OR\",\r\n      \"power\": \"med\",\r\n      \"plum\":\r\n      {\r\n        \"n\": \"EQIYPvAu6DZAIl3AORH3dCdoFOLe71iheqcywJcnjtJt\",\r\n        \"o\": \"NI2I\"\r\n      }\r\n      \"pear\":\r\n      {\r\n        \"n\": \"EJtQIYPvAu6DZAIl3AORH3dCdoFOLe71iheqcywJcnjt\",\r\n        \"o\": \"NI2I\"\r\n      }\r\n    }\r\n  }\r\n}\r\n~~~\r\n\r\n### vLEI ECR issued by QVI example\r\n\r\nWe discussed that when the ECR is issued by the QVI it is not chained, Issuer-to-Issuee, via the LE credential. More accurate chaining would be to use the `AND` operator to include both the LE and QVI credentials as edges in the ECR and also to apply the unary `NI2I` to the LE credential instead of only chaining the ECR to the LE and not chaining to ECR to the QVI at all.\r\n\r\nIn the following example: The top-level edge-block uses the default of `AND` and the `qvi` edge uses the default of `I2I` because it points to a targeted ACDC.  The `le` edge, on the other hand, points to a targeted ACDC but we want to accept it even though its targeted Issuee is not the Issuer of the current credential.  Therefore it must explicitly provide the unary operator, `NI2I` in  its operator, `o`, field. \r\n\r\n~~~json\r\n{\r\n  \"e\": \r\n  {\r\n    \"d\": \"EerzwLIr9Bf7V_NHwY1lkFrn9y2PgveY4-9XgOcLx,UdY\",\r\n    \"qvi\":\r\n    {\r\n      \"n\": \"EIl3MORH3dCdoFOLe71iheqcywJcnjtJtQIYPvAu6DZA\"\r\n    }\r\n    \"le\":\r\n    {\r\n      \"n\": \"EORH3dCdoFOLe71iheqcywJcnjtJtQIYPvAu6DZAIl3A\",\r\n      \"o\": \"NI2I\",\r\n    }\r\n  }\r\n}\r\n~~~\r\n\r\n\r\n## Commentary\r\n\r\nThis provides a simple but highly expressive syntax for applying (m-ary) aggregating operators to nestable groups of edges and unary operators to edges individually within those groups. This is a general approach with high expressive power. It satisfies many business logic requirements similar to that of SGL. \r\n\r\nCertainly, an even more expressive syntax could be developed. The proposed syntax, however, is simple, compact, has intelligent defaults, and is sufficiently general in scope to satisfy all the currently contemplated use cases.\r\n\r\nThe intelligent defaults for the operator, `o`, field, including the default application of the  `I2I` or `NI2I` unary operator, means that in most current use cases the operator, `o`, field does not even need to be present.\r\n\r\n\r\n",
          "createdAt": "2022-04-08T15:14:06Z",
          "updatedAt": "2022-04-11T19:51:16Z"
        },
        {
          "author": "SmithSamuelM",
          "authorAssociation": "COLLABORATOR",
          "body": "Accidently closed",
          "createdAt": "2022-04-11T19:30:27Z",
          "updatedAt": "2022-04-11T19:30:27Z"
        }
      ]
    },
    {
      "number": 64,
      "id": "I_kwDOGxcvRc5Nd36-",
      "title": "Terminology and Glossary ",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/issues/64",
      "state": "OPEN",
      "author": "henkvancann",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "\r\nJust checking: Is this a valid example of the amalgamation of _proof of authorship_ and _proof of authority_ in a chain of ACDCs?\r\n\r\nhttps://github.com/trustoverip/acdc/wiki/proof-of-authority#example-apc--book-rights-sold",
      "createdAt": "2022-07-09T12:55:31Z",
      "updatedAt": "2022-07-09T12:55:31Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOGxcvRc4yZz94",
      "title": "Update draft-ssmith-acdc.md",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/1",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Added field descriptions to informative examples",
      "createdAt": "2022-02-10T16:54:20Z",
      "updatedAt": "2022-02-14T15:47:15Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "8fdfc69fd98a5a60ac6cf514a69d585278bb0022",
      "headRepository": "trustoverip/tswg-acdc-specification",
      "headRefName": "SmithSamuelM-patch-1",
      "headRefOid": "dcf25b44a3a467d14762b03f8aede2130ceabc0a",
      "closedAt": "2022-02-14T15:47:15Z",
      "mergedAt": "2022-02-14T15:47:15Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "53178bf5a01689822b3bc3a0be0a545addc908cd"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 2,
      "id": "PR_kwDOGxcvRc4yy-RP",
      "title": "Update LICENSE.md",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/2",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-14T15:55:19Z",
      "updatedAt": "2022-02-14T15:57:29Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "53178bf5a01689822b3bc3a0be0a545addc908cd",
      "headRepository": "trustoverip/tswg-acdc-specification",
      "headRefName": "SmithSamuelM-patch-2",
      "headRefOid": "15bcf9b23e27f9a659261ce8b54ae232274acd75",
      "closedAt": "2022-02-14T15:57:29Z",
      "mergedAt": "2022-02-14T15:57:29Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "63ee7d7fe6a4eac8f6ccf84585fadbbcbf127a68"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 3,
      "id": "PR_kwDOGxcvRc4yy-qu",
      "title": "Update CONTRIBUTING.md",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/3",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-14T15:56:48Z",
      "updatedAt": "2022-02-14T15:57:17Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "53178bf5a01689822b3bc3a0be0a545addc908cd",
      "headRepository": "trustoverip/tswg-acdc-specification",
      "headRefName": "SmithSamuelM-patch-3",
      "headRefOid": "60509424d0f242d80418ad73bee353fd72793b5e",
      "closedAt": "2022-02-14T15:57:17Z",
      "mergedAt": "2022-02-14T15:57:17Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "903c9922e2d6020ce9415551ab37180a65a60d03"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 4,
      "id": "PR_kwDOGxcvRc4zu5Fz",
      "title": "Update draft-ssmith-acdc.md",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/4",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-03-01T14:32:40Z",
      "updatedAt": "2022-03-01T14:33:24Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "63ee7d7fe6a4eac8f6ccf84585fadbbcbf127a68",
      "headRepository": "trustoverip/tswg-acdc-specification",
      "headRefName": "SmithSamuelM-patch-4",
      "headRefOid": "99b33eb417d61b5d98fb84e8bf8e0a402f3a6200",
      "closedAt": "2022-03-01T14:33:24Z",
      "mergedAt": "2022-03-01T14:33:24Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "9b4a0d9a89c5b9b1a6a87497a13d539886552e65"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 5,
      "id": "PR_kwDOGxcvRc4zvWTQ",
      "title": "Fixed duplicate key in Yaml Sectiobn 0.01",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/5",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-03-01T16:32:53Z",
      "updatedAt": "2022-04-02T18:47:18Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "9b4a0d9a89c5b9b1a6a87497a13d539886552e65",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "9ea3ff5a13a815b4340b2df08241d5820fa2e88d",
      "closedAt": "2022-04-02T18:47:18Z",
      "mergedAt": "2022-04-02T18:47:18Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "14cbf707802ad5d7c560468774ba5f1d7d077039"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 11,
      "id": "PR_kwDOGxcvRc41mBAX",
      "title": "Started porting references",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/11",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-04-04T15:11:08Z",
      "updatedAt": "2022-04-04T15:12:34Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "14cbf707802ad5d7c560468774ba5f1d7d077039",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "7aaf6309a642fe3d97724cc009ebb66db2285a3c",
      "closedAt": "2022-04-04T15:12:34Z",
      "mergedAt": "2022-04-04T15:12:34Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "7e16c5f1eddd04ae45c5c2d370a9bb414eab8237"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 12,
      "id": "PR_kwDOGxcvRc41mDOX",
      "title": "fixing formatting issues",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/12",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-04T15:18:38Z",
      "updatedAt": "2022-04-04T15:19:47Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "7e16c5f1eddd04ae45c5c2d370a9bb414eab8237",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "2dfc8bb5bd9dd313a504a9349839834c9340b797",
      "closedAt": "2022-04-04T15:19:46Z",
      "mergedAt": "2022-04-04T15:19:46Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "91abb3dde2dbc429778796cb8cd45453370f1a3b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 13,
      "id": "PR_kwDOGxcvRc41mO8A",
      "title": "Added more references",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/13",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-04T16:04:05Z",
      "updatedAt": "2022-04-04T16:04:52Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "91abb3dde2dbc429778796cb8cd45453370f1a3b",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "f9422d6eb0b6a2ed165874b4172229a0fd74a345",
      "closedAt": "2022-04-04T16:04:52Z",
      "mergedAt": "2022-04-04T16:04:51Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "553fcd3c1a0d781a704c332ef06868ee09bf8215"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 14,
      "id": "PR_kwDOGxcvRc41mP_g",
      "title": "trying to fix reference appearance",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/14",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-04T16:07:53Z",
      "updatedAt": "2022-04-04T16:08:35Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "553fcd3c1a0d781a704c332ef06868ee09bf8215",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "9f9714651e030d82f223c1610a2bd0528f83dbb9",
      "closedAt": "2022-04-04T16:08:35Z",
      "mergedAt": "2022-04-04T16:08:35Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "106147f6ba09a696498a7c2d1bebc1c4deec3a76"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 15,
      "id": "PR_kwDOGxcvRc41mQxZ",
      "title": "trying to fix",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/15",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-04T16:10:50Z",
      "updatedAt": "2022-04-04T16:11:35Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "106147f6ba09a696498a7c2d1bebc1c4deec3a76",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "9b30804eba2a23d046483afc32090841f057fa70",
      "closedAt": "2022-04-04T16:11:35Z",
      "mergedAt": "2022-04-04T16:11:35Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "74bbf6eda4c55539660a312a6c614a47c641a264"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 16,
      "id": "PR_kwDOGxcvRc41mRkE",
      "title": "attempt to fix multi-cite reference format",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/16",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-04T16:14:04Z",
      "updatedAt": "2022-04-04T16:14:45Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "74bbf6eda4c55539660a312a6c614a47c641a264",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "b39d893e98ec622875dd577172ad456986bf3fce",
      "closedAt": "2022-04-04T16:14:45Z",
      "mergedAt": "2022-04-04T16:14:45Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "d927b8d681a26b60400ba8339b1ddc1155958869"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 17,
      "id": "PR_kwDOGxcvRc41mWS4",
      "title": "more attempts to fix multi cite format",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/17",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-04T16:33:22Z",
      "updatedAt": "2022-04-04T16:34:05Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "d927b8d681a26b60400ba8339b1ddc1155958869",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "e792b378210894f64f7590a5b8ad82b442300187",
      "closedAt": "2022-04-04T16:34:05Z",
      "mergedAt": "2022-04-04T16:34:05Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "99ef7fe35984f5f3408cfea7f3665ecc2e7afdb8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 18,
      "id": "PR_kwDOGxcvRc41mZAo",
      "title": "another variant on citing refs",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/18",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-04T16:46:38Z",
      "updatedAt": "2022-04-04T16:49:16Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "99ef7fe35984f5f3408cfea7f3665ecc2e7afdb8",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "47400fb98d6ad892a6a94d4f02aaf1ebe5d4dfc3",
      "closedAt": "2022-04-04T16:49:16Z",
      "mergedAt": "2022-04-04T16:49:16Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "6e1b6c030c6a062f4179d4d33216650317bac4be"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 19,
      "id": "PR_kwDOGxcvRc41mhTz",
      "title": "ported more references",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/19",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-04T17:25:14Z",
      "updatedAt": "2022-04-04T17:54:50Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "6e1b6c030c6a062f4179d4d33216650317bac4be",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "e6a24950d2af8bac87dc0e53d8676c2876b99738",
      "closedAt": "2022-04-04T17:54:50Z",
      "mergedAt": "2022-04-04T17:54:49Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "bb378b02c4daf792cff0e3f3158cb666fef963dd"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 20,
      "id": "PR_kwDOGxcvRc41mq2s",
      "title": "Port more references",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/20",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-04T18:08:25Z",
      "updatedAt": "2022-04-04T18:27:58Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "bb378b02c4daf792cff0e3f3158cb666fef963dd",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "b3abd4e0e84eff1699744d9e683e9b2628705edf",
      "closedAt": "2022-04-04T18:27:58Z",
      "mergedAt": "2022-04-04T18:27:58Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "dc876c0ba3a87f165ecba266836dce425397b226"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 21,
      "id": "PR_kwDOGxcvRc41nIsB",
      "title": "ported rest of refs",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/21",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-04T20:23:16Z",
      "updatedAt": "2022-04-04T20:24:02Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "dc876c0ba3a87f165ecba266836dce425397b226",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "a098f3896933249d88bbcd27f4bd7b608b766b8f",
      "closedAt": "2022-04-04T20:24:01Z",
      "mergedAt": "2022-04-04T20:24:01Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "df6d784f7feccb52bbc9058491f26aa79543411c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 22,
      "id": "PR_kwDOGxcvRc41nNPj",
      "title": "Abstract with refs",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/22",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-04T20:46:41Z",
      "updatedAt": "2022-04-04T20:47:22Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "df6d784f7feccb52bbc9058491f26aa79543411c",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "2ca2d35ab1459924288bb5a9c084a5917f3f0dc3",
      "closedAt": "2022-04-04T20:47:22Z",
      "mergedAt": "2022-04-04T20:47:22Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "0e890a10e126d714b7128f169ed83f154173d803"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 23,
      "id": "PR_kwDOGxcvRc41nPBr",
      "title": "Introduction ported",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/23",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-04T20:55:42Z",
      "updatedAt": "2022-04-04T20:56:19Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "0e890a10e126d714b7128f169ed83f154173d803",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "a30020b08dc392cfd93c469dbe89c86287ebe9d7",
      "closedAt": "2022-04-04T20:56:19Z",
      "mergedAt": "2022-04-04T20:56:19Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "6b5d6589393e0621da591e25ea0b010a194743dd"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 24,
      "id": "PR_kwDOGxcvRc41nQCK",
      "title": "Added fields table",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/24",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-04T20:59:46Z",
      "updatedAt": "2022-04-04T23:48:59Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "6b5d6589393e0621da591e25ea0b010a194743dd",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "0a5e19930e41c6da85fdbd5b231a3b602d13bef2",
      "closedAt": "2022-04-04T23:48:59Z",
      "mergedAt": "2022-04-04T23:48:59Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "817215beec645838f4a4992f9fa792d9baa1e650"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 25,
      "id": "PR_kwDOGxcvRc41nt68",
      "title": "Schema Section Ported",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/25",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-05T00:06:52Z",
      "updatedAt": "2022-04-05T00:10:07Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "817215beec645838f4a4992f9fa792d9baa1e650",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "82fcf75a0f0113594d475ad096f6dfacf4928881",
      "closedAt": "2022-04-05T00:10:06Z",
      "mergedAt": "2022-04-05T00:10:06Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "cd727ef74d6b8617d5f866308eddf60895d1f372"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 26,
      "id": "PR_kwDOGxcvRc41nva9",
      "title": "Ported ACDC types sections and Exploitation",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/26",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-05T00:17:25Z",
      "updatedAt": "2022-04-05T00:18:12Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "cd727ef74d6b8617d5f866308eddf60895d1f372",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "5caf0146bec36dd31003880dd42c414ca33f89fd",
      "closedAt": "2022-04-05T00:18:12Z",
      "mergedAt": "2022-04-05T00:18:12Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "7fa150a56cc84a703eeab921beacfd1ed63bd345"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 27,
      "id": "PR_kwDOGxcvRc41nv7H",
      "title": "Attribute Section",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/27",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-05T00:22:22Z",
      "updatedAt": "2022-04-05T00:22:58Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "7fa150a56cc84a703eeab921beacfd1ed63bd345",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "888a78a92a299e1e736b12ff071cc0c0a7a68e0a",
      "closedAt": "2022-04-05T00:22:58Z",
      "mergedAt": "2022-04-05T00:22:58Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "737a7e8167b97ff07726056e70c92795d6487391"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 28,
      "id": "PR_kwDOGxcvRc41nwVH",
      "title": "Edge Section",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/28",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-05T00:26:26Z",
      "updatedAt": "2022-04-05T00:27:04Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "737a7e8167b97ff07726056e70c92795d6487391",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "1baaea1e8e8ea0f120104235beb1b4c9c6811142",
      "closedAt": "2022-04-05T00:27:04Z",
      "mergedAt": "2022-04-05T00:27:04Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "3789da0c6c6da0960afedfbdf16d407c7b7afa3b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 29,
      "id": "PR_kwDOGxcvRc41nwoU",
      "title": "Rule Section",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/29",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-05T00:29:29Z",
      "updatedAt": "2022-04-05T00:30:13Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "3789da0c6c6da0960afedfbdf16d407c7b7afa3b",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "89b7491173c5f07c80c3392a460bc30719935a8d",
      "closedAt": "2022-04-05T00:30:13Z",
      "mergedAt": "2022-04-05T00:30:13Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "4647ac155fd94fdafc9c0491f38c0f59e6d87d2c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 30,
      "id": "PR_kwDOGxcvRc41nw6s",
      "title": "Informative Example",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/30",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-05T00:32:30Z",
      "updatedAt": "2022-04-05T00:33:13Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "4647ac155fd94fdafc9c0491f38c0f59e6d87d2c",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "e5e939a333b021ca6c295c3e4ebd94cc4c311f2b",
      "closedAt": "2022-04-05T00:33:12Z",
      "mergedAt": "2022-04-05T00:33:12Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "e6ef8ce1e3ee6d3edf16748d3d4d59fdfd08e0c8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 31,
      "id": "PR_kwDOGxcvRc41nzuI",
      "title": "Selective Disclosure Attributes",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/31",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-05T00:51:00Z",
      "updatedAt": "2022-04-05T02:14:16Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "e6ef8ce1e3ee6d3edf16748d3d4d59fdfd08e0c8",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "72d49f9d758b4a250e0985747a34683bd78b1e04",
      "closedAt": "2022-04-05T02:14:16Z",
      "mergedAt": "2022-04-05T02:14:16Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "72e5b654f13750658d57706dd043e27df8c00217"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 32,
      "id": "PR_kwDOGxcvRc41oELQ",
      "title": "Make validatable json objects in examples not simple section",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/32",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-05T03:21:56Z",
      "updatedAt": "2022-04-05T03:22:31Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "72e5b654f13750658d57706dd043e27df8c00217",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "99677a8c56ac6ff84f9dfa17aab9507d058e3655",
      "closedAt": "2022-04-05T03:22:31Z",
      "mergedAt": "2022-04-05T03:22:31Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "6ca7e18ba8115f4601be46d780576e67341e52ed"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 33,
      "id": "PR_kwDOGxcvRc41oEga",
      "title": "Added selectively disclosable attribute section",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/33",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-05T03:25:18Z",
      "updatedAt": "2022-04-05T03:25:57Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "6ca7e18ba8115f4601be46d780576e67341e52ed",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "5f839a727318d9d57fe35c8ad74293f5b2a97f9c",
      "closedAt": "2022-04-05T03:25:57Z",
      "mergedAt": "2022-04-05T03:25:57Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "6c3c4e9e834ae54805d32e4d2858bb2f4e952c14"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 34,
      "id": "PR_kwDOGxcvRc41oE_h",
      "title": "blinded attribute array",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/34",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-05T03:27:38Z",
      "updatedAt": "2022-04-05T03:32:46Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "6c3c4e9e834ae54805d32e4d2858bb2f4e952c14",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "ccd0a0021a37d8eb35dfb82567e52f7d2d914bfe",
      "closedAt": "2022-04-05T03:32:46Z",
      "mergedAt": "2022-04-05T03:32:46Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "683addcb99178c82a2482f492740bd6d3e209d1d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 35,
      "id": "PR_kwDOGxcvRc41oFrG",
      "title": "add likely error line",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/35",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-05T03:33:54Z",
      "updatedAt": "2022-04-05T03:43:49Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "683addcb99178c82a2482f492740bd6d3e209d1d",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "a5e3bb559d22cc0c88aad612c857da2355101b84",
      "closedAt": "2022-04-05T03:43:49Z",
      "mergedAt": "2022-04-05T03:43:49Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "d1b3ebe08bde832e2cc18ac079a885dac0edde19"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 36,
      "id": "PR_kwDOGxcvRc41oG2N",
      "title": "added back emphasis",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/36",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-05T03:44:49Z",
      "updatedAt": "2022-04-05T03:45:24Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "d1b3ebe08bde832e2cc18ac079a885dac0edde19",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "295a1e133bd8ab32f4c0fbd744e27c273e0a5f25",
      "closedAt": "2022-04-05T03:45:24Z",
      "mergedAt": "2022-04-05T03:45:24Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "2158fa79e07b22c63dffb8c26c71336eb62b8a82"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 37,
      "id": "PR_kwDOGxcvRc41oHQB",
      "title": "added another math line",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/37",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-05T03:47:38Z",
      "updatedAt": "2022-04-05T03:48:22Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "2158fa79e07b22c63dffb8c26c71336eb62b8a82",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "33f525b431c9f39f57f3bdecbcb724c5d8bd21d2",
      "closedAt": "2022-04-05T03:48:22Z",
      "mergedAt": "2022-04-05T03:48:22Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "050103968a0c9c73e97d75281c7b4e54c666422d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 38,
      "id": "PR_kwDOGxcvRc41oH8v",
      "title": "Added schema for selective disclosable attribute section",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/38",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-05T03:54:25Z",
      "updatedAt": "2022-04-05T03:55:06Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "050103968a0c9c73e97d75281c7b4e54c666422d",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "7986d6b1931e05ed7cd63873d4e30c06e1c5852d",
      "closedAt": "2022-04-05T03:55:06Z",
      "mergedAt": "2022-04-05T03:55:06Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "a210d763c3edff3f6a821f07ebd95e26c6f8276c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 39,
      "id": "PR_kwDOGxcvRc41oIX5",
      "title": "added rest of selectively disclosable attribute section",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/39",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-05T03:57:33Z",
      "updatedAt": "2022-04-05T03:58:10Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "a210d763c3edff3f6a821f07ebd95e26c6f8276c",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "0e69ab9286928db38f77dd65a5d14f20cb761ff4",
      "closedAt": "2022-04-05T03:58:10Z",
      "mergedAt": "2022-04-05T03:58:10Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "c630c83a09c7bbc7ab7b2132b17fc7295421f9b8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 40,
      "id": "PR_kwDOGxcvRc41oJhM",
      "title": "Added bulk issued section",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/40",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-05T04:06:09Z",
      "updatedAt": "2022-04-05T04:06:48Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "c630c83a09c7bbc7ab7b2132b17fc7295421f9b8",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "beea3c999523573e33830c63e5f24c503f7107a5",
      "closedAt": "2022-04-05T04:06:48Z",
      "mergedAt": "2022-04-05T04:06:48Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "bdc83e7000abed725d0416d30402c83a6a827f49"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 41,
      "id": "PR_kwDOGxcvRc41oKXT",
      "title": "Added appendix",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/41",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-05T04:11:47Z",
      "updatedAt": "2022-04-05T04:12:23Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "bdc83e7000abed725d0416d30402c83a6a827f49",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "835ad95e3ef15735a0c196c17c8b7c1a4698fd0e",
      "closedAt": "2022-04-05T04:12:23Z",
      "mergedAt": "2022-04-05T04:12:23Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "1e76704f400991bed778be7eb4bd62e8145ef76e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 42,
      "id": "PR_kwDOGxcvRc41qyKw",
      "title": "fix some math formating problems with Unicode",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/42",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-05T15:40:30Z",
      "updatedAt": "2022-04-05T15:41:12Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "1e76704f400991bed778be7eb4bd62e8145ef76e",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "cd7b49ae7be65a3ac61ca740c5b5b647686d67e8",
      "closedAt": "2022-04-05T15:41:12Z",
      "mergedAt": "2022-04-05T15:41:12Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "520f1266ab4fd7548c9aa4ad70f3b6185dd8f0ec"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 43,
      "id": "PR_kwDOGxcvRc41rSFH",
      "title": "fix typos in json example",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/43",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-04-05T17:36:39Z",
      "updatedAt": "2022-04-05T18:27:05Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "520f1266ab4fd7548c9aa4ad70f3b6185dd8f0ec",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "c0e6678886d804af8b593cca84ed5f99eee7f0ed",
      "closedAt": "2022-04-05T18:27:05Z",
      "mergedAt": "2022-04-05T18:27:04Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "882837993dc1b6a4fc59ade55445e9433b04b985"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 44,
      "id": "PR_kwDOGxcvRc41sI0r",
      "title": "modified descriptions for aggregate attribute sections schema",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/44",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-05T22:05:28Z",
      "updatedAt": "2022-04-06T14:01:47Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "882837993dc1b6a4fc59ade55445e9433b04b985",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "f88567907fe56a725635456d965a06ef2a60c4ec",
      "closedAt": "2022-04-06T14:01:47Z",
      "mergedAt": "2022-04-06T14:01:47Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "276e7ca3b40f9684ba6fe1836343e65dfc75462a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 45,
      "id": "PR_kwDOGxcvRc41viBN",
      "title": "Updated Readme",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/45",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-04-06T15:30:17Z",
      "updatedAt": "2022-04-06T15:30:51Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "276e7ca3b40f9684ba6fe1836343e65dfc75462a",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "b045814b549df0ee1240561824bd181e6d4338c7",
      "closedAt": "2022-04-06T15:30:51Z",
      "mergedAt": "2022-04-06T15:30:50Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "b7925fc194fd4185647cd305f7069d122319a284"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 47,
      "id": "PR_kwDOGxcvRc415FAb",
      "title": "Updated references",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/47",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-04-08T19:25:34Z",
      "updatedAt": "2022-04-08T19:27:01Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "b7925fc194fd4185647cd305f7069d122319a284",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "ed30af922f8bd824a1a0d74f9e94711e243f12f9",
      "closedAt": "2022-04-08T19:27:01Z",
      "mergedAt": "2022-04-08T19:27:01Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "f020df743d106b79606835cc7f94ea6875b61642"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 48,
      "id": "PR_kwDOGxcvRc418OJD",
      "title": "expanded definitions to include graduated disclosure and contractuall\u2026",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/48",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026y protected\r\n\r\ndisclosure\r\n\r\nSigned-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-09T15:32:21Z",
      "updatedAt": "2022-04-09T15:33:49Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "f020df743d106b79606835cc7f94ea6875b61642",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "792bb268c7c3ae3653d330b8ee5c99cb9242f769",
      "closedAt": "2022-04-09T15:33:49Z",
      "mergedAt": "2022-04-09T15:33:49Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "b944ada380abc124c93240b6fe5e954440278e45"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 49,
      "id": "PR_kwDOGxcvRc418Tne",
      "title": "added how composed schema are themselves a bundled commitment that en\u2026",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/49",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026ables secure\r\n\r\nunbundling to support safe graduated disclosure.\r\n\r\nSigned-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-09T16:32:06Z",
      "updatedAt": "2022-04-09T16:32:49Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "b944ada380abc124c93240b6fe5e954440278e45",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "1a331e8b19d91cf06034cc070ae8775891abe0af",
      "closedAt": "2022-04-09T16:32:49Z",
      "mergedAt": "2022-04-09T16:32:49Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "a89092495b9bb0b4c5796f413552b43fc0aa9c50"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 50,
      "id": "PR_kwDOGxcvRc42B4CY",
      "title": "Added Edge Operators",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/50",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-04-11T20:43:37Z",
      "updatedAt": "2022-04-11T20:44:33Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "a89092495b9bb0b4c5796f413552b43fc0aa9c50",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "b4a1cc3e84e0f1d869a1daf1bd3852348b9b48c3",
      "closedAt": "2022-04-11T20:44:33Z",
      "mergedAt": "2022-04-11T20:44:33Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "6d3f921e47a535c23df433df659355a6339325b1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 51,
      "id": "PR_kwDOGxcvRc42GEFc",
      "title": "fix typos",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/51",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-12T11:32:01Z",
      "updatedAt": "2022-04-12T11:32:50Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "6d3f921e47a535c23df433df659355a6339325b1",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "800a6e8ebb1e8054aeff0c9cb00461cc516ba23f",
      "closedAt": "2022-04-12T11:32:50Z",
      "mergedAt": "2022-04-12T11:32:49Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "6b2c0cd95c0b0e1a843527a4dfe5217db648dbf4"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 52,
      "id": "PR_kwDOGxcvRc42GE6L",
      "title": "fix more typos",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/52",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-12T11:35:14Z",
      "updatedAt": "2022-04-12T11:38:24Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "6b2c0cd95c0b0e1a843527a4dfe5217db648dbf4",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "d01bece3f5e72497d41206155ff9f14dac212b01",
      "closedAt": "2022-04-12T11:38:23Z",
      "mergedAt": "2022-04-12T11:38:23Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "c79ea61a741716c9dd25f52a4c131bef24bf10d1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 53,
      "id": "PR_kwDOGxcvRc42GF7C",
      "title": "changed Issuee-To-Issuer",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/53",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-12T11:39:09Z",
      "updatedAt": "2022-04-12T11:39:55Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "c79ea61a741716c9dd25f52a4c131bef24bf10d1",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "d4e8ed8b149033b986ee468e9a456f446618d3d6",
      "closedAt": "2022-04-12T11:39:55Z",
      "mergedAt": "2022-04-12T11:39:55Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "ab5bcdde40772e7a767c1a05a689431b27b8c08f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 54,
      "id": "PR_kwDOGxcvRc42GqSY",
      "title": "added to abstract",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/54",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-12T13:51:35Z",
      "updatedAt": "2022-04-12T13:53:48Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "ab5bcdde40772e7a767c1a05a689431b27b8c08f",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "5b0e706f5467894e829cd7becd2a36736fa1a591",
      "closedAt": "2022-04-12T13:53:48Z",
      "mergedAt": "2022-04-12T13:53:48Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "c69ad950c86d3b7dd6c0c88bc4c9727060784b78"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 55,
      "id": "PR_kwDOGxcvRc42H094",
      "title": "added appendix for performance and scalability",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/55",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-12T18:22:57Z",
      "updatedAt": "2022-04-12T18:47:41Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "c69ad950c86d3b7dd6c0c88bc4c9727060784b78",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "92c78a03c3ce96dacca2df04e099f4bb84012c12",
      "closedAt": "2022-04-12T18:47:41Z",
      "mergedAt": "2022-04-12T18:47:41Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "154503c1588cdc7ce16d06ae483009e240e58bb1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 56,
      "id": "PR_kwDOGxcvRc42IuGZ",
      "title": "fix typos",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/56",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-12T22:58:56Z",
      "updatedAt": "2022-04-12T23:21:06Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "154503c1588cdc7ce16d06ae483009e240e58bb1",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "9e9a73de83d7b9238e430ebcb23238bf1e9f86da",
      "closedAt": "2022-04-12T23:21:06Z",
      "mergedAt": "2022-04-12T23:21:06Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "6b17b95ab7aa99077ba5112be238db46f7d80cf3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 57,
      "id": "PR_kwDOGxcvRc42Mlcl",
      "title": "added Dislosure Specific ACDC section fixed some more typos",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/57",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-13T19:18:33Z",
      "updatedAt": "2022-04-13T19:20:36Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "6b17b95ab7aa99077ba5112be238db46f7d80cf3",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "4ff300c9cbdc879a46af3e9169d7b4ae188e44e0",
      "closedAt": "2022-04-13T19:20:36Z",
      "mergedAt": "2022-04-13T19:20:36Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "5f96623cda6f147c6eafefff5dfee28ae45113d0"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 58,
      "id": "PR_kwDOGxcvRc42MplT",
      "title": "fixed typos",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/58",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-13T19:40:03Z",
      "updatedAt": "2022-04-13T19:40:12Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "5f96623cda6f147c6eafefff5dfee28ae45113d0",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "e9beceb349c430abf89f5128e97c7d92e9b81987",
      "closedAt": "2022-04-13T19:40:12Z",
      "mergedAt": "2022-04-13T19:40:12Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "e3a8c4d4806c0f77c3c12535bafc035d40f3aac0"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 59,
      "id": "PR_kwDOGxcvRc42TTvh",
      "title": "Added language about Contigent Disclosure and Rich Presentation equivalency",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/59",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-04-15T18:40:11Z",
      "updatedAt": "2022-04-15T18:42:38Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "e3a8c4d4806c0f77c3c12535bafc035d40f3aac0",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "6a38d523ae2bded521fbc09baed8b6a7ec000e5b",
      "closedAt": "2022-04-15T18:42:38Z",
      "mergedAt": "2022-04-15T18:42:38Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "03d17102a74787e88be67d93012e17ceae50c102"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 60,
      "id": "PR_kwDOGxcvRc42vtcu",
      "title": "Added reference to paper on secure use of same key pair for both Ed25\u2026",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/60",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026519 and X25519\r\n\r\nSigned-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-04-25T18:18:13Z",
      "updatedAt": "2022-04-25T18:19:01Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "03d17102a74787e88be67d93012e17ceae50c102",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "32d33548fc954c774c25e3ff37b1c0469326c537",
      "closedAt": "2022-04-25T18:19:01Z",
      "mergedAt": "2022-04-25T18:19:01Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "26a45e493573f9af1eb3082f740e9317808744aa"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 61,
      "id": "PR_kwDOGxcvRc436MRX",
      "title": "Added type (as schema) constraint on far ADCD pointed to by an edge. ",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/61",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-16T21:07:33Z",
      "updatedAt": "2022-05-16T21:08:36Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "26a45e493573f9af1eb3082f740e9317808744aa",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "b13ad0fe8435656ad70d9b0990a649dfcd06516e",
      "closedAt": "2022-05-16T21:08:36Z",
      "mergedAt": "2022-05-16T21:08:36Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "2925f03aa7babdae0c4ae14e9e3771e4efe54639"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 62,
      "id": "PR_kwDOGxcvRc439ZAp",
      "title": "added field ordering normative requirement.",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/62",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Samuel M Smith <sam@samuelsmith.org>",
      "createdAt": "2022-05-17T13:44:39Z",
      "updatedAt": "2022-05-17T13:47:16Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "2925f03aa7babdae0c4ae14e9e3771e4efe54639",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "e2ea4a2ce1d394841306d329266ac8008e726dbc",
      "closedAt": "2022-05-17T13:47:16Z",
      "mergedAt": "2022-05-17T13:47:16Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "45f4e3ba08d264049fd25c15d9fdb848df6899c7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 63,
      "id": "PR_kwDOGxcvRc46C03n",
      "title": "fixed typos. some reorg of Selective Disclosure section added tiered \u2026",
      "url": "https://github.com/trustoverip/tswg-acdc-specification/pull/63",
      "state": "MERGED",
      "author": "SmithSamuelM",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026selective disclosure.",
      "createdAt": "2022-06-21T16:56:34Z",
      "updatedAt": "2022-06-21T16:57:13Z",
      "baseRepository": "trustoverip/tswg-acdc-specification",
      "baseRefName": "main",
      "baseRefOid": "45f4e3ba08d264049fd25c15d9fdb848df6899c7",
      "headRepository": "SmithSamuelM/ietf-acdc",
      "headRefName": "main",
      "headRefOid": "0e37e459296e94b563507dcd2b631953176f0e29",
      "closedAt": "2022-06-21T16:57:13Z",
      "mergedAt": "2022-06-21T16:57:13Z",
      "mergedBy": "SmithSamuelM",
      "mergeCommit": {
        "oid": "a4b9313353f01d98d4982ceb6dad65c9d84c429b"
      },
      "comments": [],
      "reviews": []
    }
  ]
}